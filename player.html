<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PALM 재생</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fjalla+One&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: white;
            overflow: hidden;
        }

        .header {
            padding: 15px 20px 15px 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            color: white;
            font-size: 1.2rem;
            font-weight: normal;
            margin-bottom: 0px;
            flex: 1;
            font-family: 'Fjalla One', sans-serif;
        }
        
        .nav-arrow {
            background: none;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 18px;
            transition: all 0.3s ease;
            padding: 10px;
        }
        
        .nav-arrow:hover {
            opacity: 0.7;
            transform: scale(1.1);
        }
        
        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .nav-arrow:disabled:hover {
            opacity: 0.3;
            transform: none;
        }
        
        /* Expression Modal Styles */
        .expression-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }
        
        .expression-modal-content {
            background: white;
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            padding: 20px 16px;
            max-width: 600px;
            width: 100%;
            max-height: 85vh;
            overflow-y: visible;
            position: relative;
            height: fit-content;
        }
        
        .expression-modal-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .expression-modal-title {
            font-size: 25.6px;
            font-weight: bold;
            color: #1a1a1a;
            margin-bottom: 8px;
            cursor: pointer;
            transition: color 0.3s;
        }
        
        .expression-modal-title:hover {
            color: #3b82f6;
        }
        
        .expression-modal-meaning {
            font-size: 18px;
            color: #666;
        }
        
        .expression-modal-examples {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .expression-example {
            border-left: 4px solid #c084fc;
            padding: 6px 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 0 8px 8px 0;
        }
        
        .expression-example:hover {
            background-color: #f9fafb;
        }
        
        .expression-example-jp {
            font-size: 18px;
            font-weight: bold;
            color: #1a1a1a;
            margin-bottom: 2px;
        }
        
        .expression-example-kr {
            font-size: 14px;
            color: #6b7280;
        }
        
        .expression-modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 5px;
        }
        
        .expression-modal-close:hover {
            color: #000;
        }

        .header p {
            font-size: 16px;
            opacity: 0.8;
        }

        .player-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            padding-top: 20px;
            padding-bottom: 20px;
            min-height: 0;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            justify-content: flex-start;
            margin-bottom: 0px;
            width: 100%;
            box-sizing: border-box;
        }

        .card-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 0px 30px 15px 30px;
            margin-bottom: 15px;
            width: 100%;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            max-height: 60vh;
        }

        .card-japanese {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            margin-top: 0px;
            line-height: 1.3;
        }

        .card-korean {
            font-size: 18px;
            opacity: 0.9;
            line-height: 1.3;
            margin-bottom: 0;
        }

        .character-display {
            margin-bottom: 15px;
        }

        .character-display img {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid rgba(255, 255, 255, 0.3);
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .bottom-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: auto;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            font-size: 20px;
            font-family: Arial, sans-serif;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .play-btn {
            width: 80px;
            height: 80px;
            font-size: 30px;
            background: rgba(255, 255, 255, 0.3);
            font-family: Arial, sans-serif;
        }

        .play-btn.playing {
            background: rgba(255, 100, 100, 0.5);
        }

        .progress-info {
            text-align: center;
            font-size: 16px;
            opacity: 0.8;
            margin-bottom: 20px;
            font-family: 'Fjalla One', sans-serif;
            font-weight: normal;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-top: 0;
            margin-bottom: 0;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Fjalla One', sans-serif;
            font-weight: normal;
            font-size: 18px;
        }

        .mode-btn.active {
            background: rgba(255, 255, 255, 0.4);
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        @media (max-width: 768px) {
            .card-display {
                padding: 0px 20px 20px 20px;
                margin-bottom: 20px;
            }

            .card-japanese {
                font-size: 24px;
            }

            .card-korean {
                font-size: 18px;
            }

            .controls {
                gap: 15px;
            }

            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 18px;
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 50%;
                color: white;
                font-family: Arial, sans-serif;
            }

            .play-btn {
                width: 70px;
                height: 70px;
                font-size: 25px;
                background: rgba(255, 255, 255, 0.3);
                font-family: Arial, sans-serif;
            }
            
            .play-btn.playing {
                background: rgba(255, 100, 100, 0.5);
            }
        }
    </style>
</head>
<body>

    
    <div class="header">
        <button class="nav-arrow" id="prev-sequence-btn" onclick="navigateToPreviousSequence()"><i class="fa-solid fa-arrow-left" style="color: white;"></i></button>
        <h1 id="sequence-title" style="cursor: pointer;" onclick="goHome()">PALM 재생</h1>
        <button class="nav-arrow" id="next-sequence-btn" onclick="navigateToNextSequence()"><i class="fa-solid fa-arrow-right" style="color: white;"></i></button>
    </div>

    <div class="player-container">
        <div class="main-content">
            <div class="card-display">
                <div class="character-display">
                    <img id="character-image" src="" alt="캐릭터" style="display: none;">
                </div>
                <div class="card-japanese" id="japanese-text">재생을 시작하세요</div>
                <div class="card-korean" id="korean-text">Press play to start</div>
            </div>

            <div class="progress-info">
                <span id="current-card">0</span> / <span id="total-cards">0</span>
            </div>
        </div>
        
        <div class="bottom-controls">
            <div class="controls">
                <button class="control-btn" id="prev-btn"><i class="fa-solid fa-backward" style="color: white;"></i></button>
                <button class="control-btn play-btn" id="play-btn"><i class="fa-solid fa-play" style="color: white;"></i></button>
                <button class="control-btn" id="next-btn"><i class="fa-solid fa-forward" style="color: white;"></i></button>
            </div>
            
            <div class="mode-selector">
                <button class="mode-btn active" id="basic-mode">Basic</button>
                <button class="mode-btn" id="expression-mode">Expression</button>
            </div>
        </div>
    </div>

    <!-- Expression Modal -->
    <div class="expression-modal" id="expression-modal">
        <div class="expression-modal-content">
            <button class="expression-modal-close" onclick="closeExpressionModal()">&times;</button>
            <div class="expression-modal-header">
                <div class="expression-modal-title" id="expression-modal-title"></div>
                <div class="expression-modal-meaning" id="expression-modal-meaning"></div>
            </div>
            <div class="expression-modal-examples" id="expression-modal-examples"></div>
        </div>
    </div>

    <script>
        let currentCards = [];
        let currentIndex = 0;
        let isPlaying = false;
        let currentMode = 'basic'; // 'basic' or 'expression'
        let currentSequence = '';
        let preloadedAudio = {};
        let currentAudio = null;
        let playbackTimeout = null;
        let isAutoAdvancing = false;
        let allSequences = ['#001', '#002', '#003', '#004', '#005', '#006', '#007'];
        let currentExpressionModal = null;

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const sequence = urlParams.get('sequence');
        const mode = urlParams.get('mode') || 'basic';
        const autoplay = urlParams.get('autoplay') === 'true';

        // Initialize player
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('URL params:', window.location.search);
            console.log('Sequence from URL:', sequence);
            console.log('Mode from URL:', mode);
            
            if (!sequence) {
                alert('시퀀스 정보가 없습니다. URL: ' + window.location.href);
                goBack();
                return;
            }

            currentSequence = sequence;
            currentMode = mode;
            
            // Update UI
            document.getElementById('sequence-title').textContent = `PALM ${sequence}`;
            
            // Update navigation buttons
            updateNavigationButtons();
            
            if (mode === 'expression') {
                document.getElementById('expression-mode').classList.add('active');
                document.getElementById('basic-mode').classList.remove('active');
            }

            // Load flashcards with fast loading
            await loadFlashcardsQuick();
            
            // Set up event listeners
            setupEventListeners();
            
            // Display first card
            displayCard(0);
            
            // Start playback automatically if autoplay is enabled
            if (autoplay) {
                console.log('Auto-starting playback due to autoplay flag');
                setTimeout(() => {
                    startPlayback();
                }, 500); // Reduced delay for faster start
            }
        });

        async function loadFlashcardsQuick() {
            try {
                console.log('Ultra-quick loading flashcards for sequence:', currentSequence);
                
                // Start loading data immediately
                const loadingPromise = loadFlashcardData();
                
                // Show first card immediately with loading text
                document.getElementById('japanese-text').textContent = '준비 중...';
                document.getElementById('korean-text').textContent = 'Getting ready...';
                
                // Wait for data to load
                await loadingPromise;
                
            } catch (error) {
                console.error('Error loading flashcards:', error);
                alert('카드를 불러오는 중 오류가 발생했습니다: ' + error.message);
                goBack();
            }
        }

        async function loadFlashcardData() {
            // Try to get specific episode data first
            let response = await fetch(`/api/flashcards?episode=${encodeURIComponent(currentSequence)}`);
            if (!response.ok) {
                // Fall back to general flashcards endpoint
                response = await fetch('/api/flashcards');
            }
            
            const data = await response.json();
            console.log('Received data:', data);
            
            // Find cards for current sequence
            if (Array.isArray(data)) {
                // Flat array format
                currentCards = data.filter(card => card.sequence === currentSequence);
            } else if (data && typeof data === 'object') {
                // Grouped format - try different ways to access the data
                currentCards = data[currentSequence] || [];
                
                // If not found, try converting grouped data to flat array
                if (currentCards.length === 0) {
                    const flatCards = [];
                    for (const [seq, cards] of Object.entries(data)) {
                        if (Array.isArray(cards)) {
                            flatCards.push(...cards);
                        }
                    }
                    currentCards = flatCards.filter(card => card.sequence === currentSequence);
                }
            } else {
                throw new Error('Invalid data format received');
            }

            console.log(`Found ${currentCards.length} cards for sequence ${currentSequence}`);
            document.getElementById('total-cards').textContent = currentCards.length;
            
            if (currentCards.length === 0) {
                alert(`시퀀스 ${currentSequence}에 카드가 없습니다.`);
                goBack();
                return;
            }
            
            // Preload first card only for immediate playback
            await preloadFirstCardOnly();
            
            // Start background loading of remaining cards
            setTimeout(() => {
                preloadRemainingCards();
            }, 100);
        }

        async function preloadFirstCardOnly() {
            // Preload only the first card for immediate playback
            if (currentCards.length > 0) {
                const card = currentCards[0];
                if (card.audioUrl) {
                    try {
                        const audio = new Audio(card.audioUrl);
                        audio.preload = 'auto';
                        preloadedAudio[card.audioUrl] = audio;
                        console.log('First card audio preloaded');
                    } catch (error) {
                        console.log('Error preloading first card audio:', card.audioUrl);
                    }
                }
                
                // Preload Korean audio for first card too
                if (card.koreanAudioUrl) {
                    try {
                        const audio = new Audio(card.koreanAudioUrl);
                        audio.preload = 'auto';
                        preloadedAudio[card.koreanAudioUrl] = audio;
                        console.log('First card Korean audio preloaded');
                    } catch (error) {
                        console.log('Error preloading first card Korean audio:', card.koreanAudioUrl);
                    }
                }
            }
        }

        async function preloadRemainingCards() {
            console.log('Starting background preload of remaining cards');
            
            for (let i = 1; i < currentCards.length; i++) {
                const card = currentCards[i];
                
                // Preload Japanese audio
                if (card.audioUrl && !preloadedAudio[card.audioUrl]) {
                    try {
                        const audio = new Audio(card.audioUrl);
                        audio.preload = 'auto';
                        preloadedAudio[card.audioUrl] = audio;
                    } catch (error) {
                        console.log('Error preloading audio:', card.audioUrl);
                    }
                }
                
                // Preload Korean audio
                if (card.koreanAudioUrl && !preloadedAudio[card.koreanAudioUrl]) {
                    try {
                        const audio = new Audio(card.koreanAudioUrl);
                        audio.preload = 'auto';
                        preloadedAudio[card.koreanAudioUrl] = audio;
                    } catch (error) {
                        console.log('Error preloading Korean audio:', card.koreanAudioUrl);
                    }
                }
                
                // Small delay to prevent overwhelming the network
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            console.log('Background preload completed');
        }

        function setupEventListeners() {
            document.getElementById('play-btn').addEventListener('click', togglePlayback);
            document.getElementById('prev-btn').addEventListener('click', previousCard);
            document.getElementById('next-btn').addEventListener('click', nextCard);
            document.getElementById('basic-mode').addEventListener('click', () => switchMode('basic'));
            document.getElementById('expression-mode').addEventListener('click', () => switchMode('expression'));
        }

        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${mode}-mode`).classList.add('active');
            
            // Stop current playback
            stopPlayback();
            
            // Auto-start playback with new mode
            setTimeout(() => {
                startPlayback();
            }, 100);
        }

        function displayCard(index) {
            if (index < 0 || index >= currentCards.length) return;
            
            currentIndex = index;
            const card = currentCards[index];
            
            console.log(`Displaying card ${index + 1}:`, card.japanese);
            
            document.getElementById('japanese-text').textContent = card.japanese;
            document.getElementById('korean-text').textContent = card.korean;
            document.getElementById('current-card').textContent = index + 1;
            
            // Update character image
            const characterImg = document.getElementById('character-image');
            if (card.characterImageUrl) {
                characterImg.src = card.characterImageUrl;
                characterImg.style.display = 'block';
            } else {
                characterImg.style.display = 'none';
            }
            
            // Auto-start playback for manually navigated cards when playing
            if (isPlaying && !isAutoAdvancing) {
                console.log('Auto-starting playback for manually navigated card');
                setTimeout(() => {
                    if (currentMode === 'basic') {
                        playBasicMode();
                    } else {
                        playExpressionMode();
                    }
                }, 500); // Small delay to ensure UI is updated
            }
        }

        async function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
            } else {
                await startPlayback();
            }
        }

        async function startPlayback() {
            isPlaying = true;
            document.getElementById('play-btn').innerHTML = '<i class="fa-solid fa-pause" style="color: white;"></i>';
            document.getElementById('play-btn').classList.add('playing');
            
            if (currentMode === 'basic') {
                await playBasicMode();
            } else {
                await playExpressionMode();
            }
        }

        function stopPlayback() {
            console.log('Stopping playback');
            isPlaying = false;
            document.getElementById('play-btn').innerHTML = '<i class="fa-solid fa-play" style="color: white;"></i>';
            document.getElementById('play-btn').classList.remove('playing');
            
            if (currentAudio) {
                console.log('Stopping current audio');
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            
            if (playbackTimeout) {
                clearTimeout(playbackTimeout);
                playbackTimeout = null;
            }
            
            // Stop TTS
            if (window.speechSynthesis) {
                console.log('Stopping TTS');
                window.speechSynthesis.cancel();
            }
            
            // Close expression modal when stopping
            closeExpressionModal();
        }

        async function playBasicMode() {
            const card = currentCards[currentIndex];
            
            try {
                // Play Japanese audio
                if (card.audioUrl) {
                    await playAudioFile(card.audioUrl);
                }
                
                if (!isPlaying) return;
                
                // Wait 3 seconds
                await sleep(3000);
                
                if (!isPlaying) return;
                
                // Play Korean audio
                if (card.koreanAudioUrl) {
                    await playAudioFile(card.koreanAudioUrl);
                }
                
                // Auto advance to next card
                if (isPlaying && currentIndex < currentCards.length - 1) {
                    await sleep(1000);
                    if (isPlaying) {
                        console.log('Auto advancing to next card');
                        autoNextCard();
                        await playBasicMode();
                    }
                } else {
                    console.log('Reached end of cards or playback stopped');
                    stopPlayback();
                    // Auto-advance to next sequence
                    await autoAdvanceToNextSequence();
                }
            } catch (error) {
                console.error('Error in basic mode playback:', error);
                stopPlayback();
            }
        }

        async function playExpressionMode() {
            const card = currentCards[currentIndex];
            
            try {
                // Play Japanese audio
                if (card.audioUrl) {
                    await playAudioFile(card.audioUrl);
                }
                
                if (!isPlaying) return;
                
                // Wait 3 seconds
                await sleep(3000);
                
                if (!isPlaying) return;
                
                // Play Korean audio
                if (card.koreanAudioUrl) {
                    await playAudioFile(card.koreanAudioUrl);
                }
                
                if (!isPlaying) return;
                
                // Load and play expressions
                await loadAndPlayExpressions(card);
                
                // Auto advance to next card
                if (isPlaying && currentIndex < currentCards.length - 1) {
                    await sleep(1000);
                    if (isPlaying) {
                        console.log('Auto advancing to next card (expression mode)');
                        autoNextCard();
                        await playExpressionMode();
                    }
                } else {
                    console.log('Reached end of cards or playback stopped (expression mode)');
                    stopPlayback();
                    // Auto-advance to next sequence
                    await autoAdvanceToNextSequence();
                }
            } catch (error) {
                console.error('Error in expression mode playback:', error);
                stopPlayback();
            }
        }

        async function loadAndPlayExpressions(card) {
            if (!card.expressionCardIds || card.expressionCardIds.length === 0) {
                return;
            }
            
            // Load expressions if not already loaded
            if (!card.expressions) {
                card.expressions = [];
                
                for (const expressionId of card.expressionCardIds) {
                    try {
                        const response = await fetch(`/api/expression/${expressionId}`);
                        if (response.ok) {
                            const expressionData = await response.json();
                            
                            const transformedExpression = {
                                mainExpression: expressionData.title,
                                meaning: expressionData.meaning || expressionData['뜻(한국어)'] || '',
                                examples: []
                            };
                            
                            // Add examples
                            for (let j = 1; j <= 5; j++) {
                                const japaneseExample = expressionData[`application${j}`];
                                const koreanExample = expressionData[`application${j}Korean`];
                                
                                if (japaneseExample && koreanExample) {
                                    transformedExpression.examples.push({
                                        japanese: japaneseExample,
                                        korean: koreanExample
                                    });
                                }
                            }
                            
                            card.expressions.push(transformedExpression);
                        }
                    } catch (error) {
                        console.error(`Error loading expression ${expressionId}:`, error);
                    }
                }
            }
            
            // Play expressions
            if (card.expressions && card.expressions.length > 0) {
                for (const expr of card.expressions) {
                    if (!isPlaying) break;
                    
                    console.log(`Playing expression: ${expr.mainExpression}`);
                    
                    // Show expression modal
                    showExpressionModal(expr);
                    
                    // Announce "표현" before reading the meaning
                    await playTTSAudio('표현', 'ko');
                    
                    if (!isPlaying) break;
                    
                    // Wait 1 second
                    await sleep(1000);
                    
                    if (!isPlaying) break;
                    
                    // Read the meaning in Korean
                    if (expr.meaning) {
                        console.log(`Reading meaning: ${expr.meaning}`);
                        await playTTSAudio(expr.meaning, 'ko');
                        
                        if (!isPlaying) break;
                        
                        // Wait 2 seconds before examples
                        await sleep(2000);
                    }
                    
                    // Play examples
                    if (expr.examples && expr.examples.length > 0) {
                        for (const example of expr.examples) {
                            if (!isPlaying) break;
                            
                            console.log(`Playing example: ${example.japanese} → ${example.korean}`);
                            
                            // Play Japanese example
                            if (example.japanese) {
                                await playTTSAudio(example.japanese, 'ja');
                            }
                            
                            if (!isPlaying) break;
                            
                            // Wait 2 seconds
                            await sleep(2000);
                            
                            if (!isPlaying) break;
                            
                            // Play Korean example
                            if (example.korean) {
                                await playTTSAudio(example.korean, 'ko');
                            }
                            
                            if (!isPlaying) break;
                            
                            await sleep(1000);
                        }
                    }
                    
                    // Close modal after expression is done
                    closeExpressionModal();
                    
                    // Wait before next expression
                    await sleep(1000);
                }
            }
        }

        function playAudioFile(url) {
            return new Promise((resolve) => {
                if (!isPlaying) {
                    resolve();
                    return;
                }
                
                // Use preloaded audio if available
                let audio = preloadedAudio[url];
                if (!audio) {
                    audio = new Audio(url);
                    preloadedAudio[url] = audio;
                }
                
                // Reset audio to beginning
                audio.currentTime = 0;
                currentAudio = audio;
                
                audio.onended = () => {
                    currentAudio = null;
                    resolve();
                };
                
                audio.onerror = () => {
                    console.error('Audio playback error:', url);
                    currentAudio = null;
                    resolve();
                };
                
                audio.play().catch(error => {
                    console.error('Audio play error:', error);
                    currentAudio = null;
                    resolve();
                });
            });
        }

        function playTTSAudio(text, language) {
            return new Promise((resolve) => {
                if (!window.speechSynthesis || !isPlaying) {
                    resolve();
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = language === 'ko' ? 'ko-KR' : 'ja-JP';
                utterance.rate = 1.2;
                
                const voices = window.speechSynthesis.getVoices();
                if (voices.length > 0) {
                    const targetVoice = voices.find(voice => 
                        voice.lang.startsWith(language === 'ko' ? 'ko' : 'ja')
                    );
                    if (targetVoice) {
                        utterance.voice = targetVoice;
                    }
                }
                
                utterance.onend = () => resolve();
                utterance.onerror = () => resolve();
                
                window.speechSynthesis.speak(utterance);
            });
        }

        function sleep(ms) {
            return new Promise(resolve => {
                if (!isPlaying) {
                    resolve();
                    return;
                }
                playbackTimeout = setTimeout(resolve, ms);
            });
        }

        function previousCard() {
            if (currentIndex > 0) {
                const wasPlaying = isPlaying;
                // Stop current playback when changing cards
                stopPlayback();
                displayCard(currentIndex - 1);
                // If it was playing, restart playback for new card
                if (wasPlaying) {
                    setTimeout(() => {
                        startPlayback();
                    }, 100);
                }
            }
        }

        function nextCard() {
            if (currentIndex < currentCards.length - 1) {
                const wasPlaying = isPlaying;
                // Stop current playback when changing cards
                stopPlayback();
                displayCard(currentIndex + 1);
                // If it was playing, restart playback for new card
                if (wasPlaying) {
                    setTimeout(() => {
                        startPlayback();
                    }, 100);
                }
            }
        }

        function autoNextCard() {
            if (currentIndex < currentCards.length - 1) {
                // Don't stop playback for auto-advance
                isAutoAdvancing = true;
                displayCard(currentIndex + 1);
                isAutoAdvancing = false;
            }
        }

        function goBack() {
            window.history.back();
        }

        function goHome() {
            window.location.href = '/';
        }
        
        function navigateToPreviousSequence() {
            const currentIndex = allSequences.indexOf(currentSequence);
            if (currentIndex > 0) {
                const prevSequence = allSequences[currentIndex - 1];
                navigateToSequence(prevSequence);
            }
        }
        
        function navigateToNextSequence() {
            const currentIndex = allSequences.indexOf(currentSequence);
            if (currentIndex < allSequences.length - 1) {
                const nextSequence = allSequences[currentIndex + 1];
                navigateToSequence(nextSequence);
            }
        }
        
        function navigateToSequence(sequence) {
            // Stop current playback
            stopPlayback();
            
            // Navigate to new sequence with autoplay enabled
            const newUrl = `/player.html?sequence=${encodeURIComponent(sequence)}&mode=${currentMode}&autoplay=true`;
            window.location.href = newUrl;
        }
        
        function updateNavigationButtons() {
            const currentIndex = allSequences.indexOf(currentSequence);
            const prevBtn = document.getElementById('prev-sequence-btn');
            const nextBtn = document.getElementById('next-sequence-btn');
            
            if (prevBtn) {
                prevBtn.disabled = currentIndex <= 0;
            }
            if (nextBtn) {
                nextBtn.disabled = currentIndex >= allSequences.length - 1;
            }
        }
        
        function showExpressionModal(expression) {
            const modal = document.getElementById('expression-modal');
            const title = document.getElementById('expression-modal-title');
            const meaning = document.getElementById('expression-modal-meaning');
            const examples = document.getElementById('expression-modal-examples');
            
            // Set content
            title.textContent = expression.mainExpression;
            meaning.textContent = expression.meaning || '';
            
            // Clear and populate examples
            examples.innerHTML = '';
            if (expression.examples && expression.examples.length > 0) {
                expression.examples.forEach(example => {
                    const exampleDiv = document.createElement('div');
                    exampleDiv.className = 'expression-example';
                    exampleDiv.innerHTML = `
                        <div class="expression-example-jp">${example.japanese}</div>
                        <div class="expression-example-kr">${example.korean}</div>
                    `;
                    examples.appendChild(exampleDiv);
                });
            }
            
            // Show modal
            modal.style.display = 'flex';
            currentExpressionModal = expression;
        }
        
        function closeExpressionModal() {
            const modal = document.getElementById('expression-modal');
            modal.style.display = 'none';
            currentExpressionModal = null;
        }
        
        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('expression-modal');
            if (event.target === modal) {
                closeExpressionModal();
            }
        });

        async function autoAdvanceToNextSequence() {
            try {
                const currentSequenceNumber = parseInt(currentSequence.replace('#', ''));
                const nextSequenceNumber = currentSequenceNumber + 1;
                const nextSequence = `#${nextSequenceNumber.toString().padStart(3, '0')}`;
                
                console.log(`Auto-advancing from ${currentSequence} to ${nextSequence}`);
                
                // Check if next sequence has cards
                const response = await fetch('/api/flashcards');
                const data = await response.json();
                
                let hasNextSequence = false;
                if (Array.isArray(data)) {
                    hasNextSequence = data.some(card => card.sequence === nextSequence);
                } else if (data && typeof data === 'object') {
                    hasNextSequence = data[nextSequence] && data[nextSequence].length > 0;
                }
                
                if (hasNextSequence) {
                    // Navigate to next sequence with autoplay flag
                    console.log(`Navigating to next sequence: ${nextSequence}`);
                    window.location.href = `player.html?sequence=${encodeURIComponent(nextSequence)}&mode=${currentMode}&autoplay=true`;
                } else {
                    console.log('No more sequences available');
                    // Could add a completion message or navigate back to home
                    setTimeout(() => {
                        alert('모든 시퀀스를 완료했습니다!');
                        window.location.href = '/';
                    }, 1000);
                }
            } catch (error) {
                console.error('Error in autoAdvanceToNextSequence:', error);
                // Silently fail - just don't advance
            }
        }
    </script>
</body>
</html>