<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PALM 재생</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: white;
        }

        .header {
            padding: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 16px;
            opacity: 0.8;
        }

        .player-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .card-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 600px;
            width: 100%;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card-japanese {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .card-korean {
            font-size: 20px;
            opacity: 0.9;
            line-height: 1.4;
        }

        .character-display {
            margin-bottom: 20px;
        }

        .character-display img {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid rgba(255, 255, 255, 0.3);
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            font-size: 20px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .play-btn {
            width: 80px;
            height: 80px;
            font-size: 30px;
            background: rgba(255, 255, 255, 0.3);
        }

        .play-btn.playing {
            background: rgba(255, 100, 100, 0.5);
        }

        .progress-info {
            text-align: center;
            font-size: 16px;
            opacity: 0.8;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: rgba(255, 255, 255, 0.4);
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        @media (max-width: 768px) {
            .card-display {
                padding: 20px;
                margin-bottom: 20px;
            }

            .card-japanese {
                font-size: 24px;
            }

            .card-korean {
                font-size: 18px;
            }

            .controls {
                gap: 15px;
            }

            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }

            .play-btn {
                width: 70px;
                height: 70px;
                font-size: 25px;
            }
        }
    </style>
</head>
<body>
    <button class="back-btn" onclick="goBack()">←</button>
    
    <div class="header">
        <h1 id="sequence-title">PALM 재생</h1>
        <p id="sequence-description">일본어 학습</p>
    </div>

    <div class="player-container">
        <div class="mode-selector">
            <button class="mode-btn active" id="basic-mode">기본 모드</button>
            <button class="mode-btn" id="expression-mode">표현 학습</button>
        </div>

        <div class="card-display">
            <div class="character-display">
                <img id="character-image" src="" alt="캐릭터" style="display: none;">
            </div>
            <div class="card-japanese" id="japanese-text">재생을 시작하세요</div>
            <div class="card-korean" id="korean-text">Press play to start</div>
        </div>

        <div class="controls">
            <button class="control-btn" id="prev-btn">⏮</button>
            <button class="control-btn play-btn" id="play-btn">▶</button>
            <button class="control-btn" id="next-btn">⏭</button>
        </div>

        <div class="progress-info">
            <span id="current-card">0</span> / <span id="total-cards">0</span>
        </div>
    </div>

    <script>
        let currentCards = [];
        let currentIndex = 0;
        let isPlaying = false;
        let currentMode = 'basic'; // 'basic' or 'expression'
        let currentSequence = '';
        let preloadedAudio = {};
        let currentAudio = null;
        let playbackTimeout = null;
        let isAutoAdvancing = false;

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const sequence = urlParams.get('sequence');
        const mode = urlParams.get('mode') || 'basic';

        // Initialize player
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('URL params:', window.location.search);
            console.log('Sequence from URL:', sequence);
            console.log('Mode from URL:', mode);
            
            if (!sequence) {
                alert('시퀀스 정보가 없습니다. URL: ' + window.location.href);
                goBack();
                return;
            }

            currentSequence = sequence;
            currentMode = mode;
            
            // Update UI
            document.getElementById('sequence-title').textContent = `PALM ${sequence}`;
            document.getElementById('sequence-description').textContent = `${mode === 'expression' ? '표현 학습' : '기본 학습'} 모드`;
            
            if (mode === 'expression') {
                document.getElementById('expression-mode').classList.add('active');
                document.getElementById('basic-mode').classList.remove('active');
            }

            // Load flashcards
            await loadFlashcards();
            
            // Set up event listeners
            setupEventListeners();
            
            // Display first card
            displayCard(0);
        });

        async function loadFlashcards() {
            try {
                console.log('Loading flashcards for sequence:', currentSequence);
                
                // Try to get specific episode data first
                let response = await fetch(`/api/flashcards?episode=${encodeURIComponent(currentSequence)}`);
                if (!response.ok) {
                    // Fall back to general flashcards endpoint
                    response = await fetch('/api/flashcards');
                }
                
                const data = await response.json();
                console.log('Received data:', data);
                
                // Find cards for current sequence
                if (Array.isArray(data)) {
                    // Flat array format
                    currentCards = data.filter(card => card.sequence === currentSequence);
                } else if (data && typeof data === 'object') {
                    // Grouped format - try different ways to access the data
                    currentCards = data[currentSequence] || [];
                    
                    // If not found, try converting grouped data to flat array
                    if (currentCards.length === 0) {
                        const flatCards = [];
                        for (const [seq, cards] of Object.entries(data)) {
                            if (Array.isArray(cards)) {
                                flatCards.push(...cards);
                            }
                        }
                        currentCards = flatCards.filter(card => card.sequence === currentSequence);
                    }
                } else {
                    throw new Error('Invalid data format received');
                }

                console.log(`Found ${currentCards.length} cards for sequence ${currentSequence}`);
                document.getElementById('total-cards').textContent = currentCards.length;
                
                if (currentCards.length === 0) {
                    alert(`시퀀스 ${currentSequence}에 카드가 없습니다.`);
                    goBack();
                }
            } catch (error) {
                console.error('Error loading flashcards:', error);
                alert('카드를 불러오는 중 오류가 발생했습니다: ' + error.message);
                goBack();
            }
        }

        function setupEventListeners() {
            document.getElementById('play-btn').addEventListener('click', togglePlayback);
            document.getElementById('prev-btn').addEventListener('click', previousCard);
            document.getElementById('next-btn').addEventListener('click', nextCard);
            document.getElementById('basic-mode').addEventListener('click', () => switchMode('basic'));
            document.getElementById('expression-mode').addEventListener('click', () => switchMode('expression'));
        }

        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${mode}-mode`).classList.add('active');
            
            // Stop current playback
            stopPlayback();
        }

        function displayCard(index) {
            if (index < 0 || index >= currentCards.length) return;
            
            currentIndex = index;
            const card = currentCards[index];
            
            console.log(`Displaying card ${index + 1}:`, card.japanese);
            
            document.getElementById('japanese-text').textContent = card.japanese;
            document.getElementById('korean-text').textContent = card.korean;
            document.getElementById('current-card').textContent = index + 1;
            
            // Update character image
            const characterImg = document.getElementById('character-image');
            if (card.characterImageUrl) {
                characterImg.src = card.characterImageUrl;
                characterImg.style.display = 'block';
            } else {
                characterImg.style.display = 'none';
            }
            
            // Auto-start playback for manually navigated cards when playing
            if (isPlaying && !isAutoAdvancing) {
                console.log('Auto-starting playback for manually navigated card');
                setTimeout(() => {
                    if (currentMode === 'basic') {
                        playBasicMode();
                    } else {
                        playExpressionMode();
                    }
                }, 500); // Small delay to ensure UI is updated
            }
        }

        async function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
            } else {
                await startPlayback();
            }
        }

        async function startPlayback() {
            isPlaying = true;
            document.getElementById('play-btn').textContent = '⏸';
            document.getElementById('play-btn').classList.add('playing');
            
            if (currentMode === 'basic') {
                await playBasicMode();
            } else {
                await playExpressionMode();
            }
        }

        function stopPlayback() {
            console.log('Stopping playback');
            isPlaying = false;
            document.getElementById('play-btn').textContent = '▶';
            document.getElementById('play-btn').classList.remove('playing');
            
            if (currentAudio) {
                console.log('Stopping current audio');
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            
            if (playbackTimeout) {
                clearTimeout(playbackTimeout);
                playbackTimeout = null;
            }
            
            // Stop TTS
            if (window.speechSynthesis) {
                console.log('Stopping TTS');
                window.speechSynthesis.cancel();
            }
        }

        async function playBasicMode() {
            const card = currentCards[currentIndex];
            
            try {
                // Play Japanese audio
                if (card.audioUrl) {
                    await playAudioFile(card.audioUrl);
                }
                
                if (!isPlaying) return;
                
                // Wait 3 seconds
                await sleep(3000);
                
                if (!isPlaying) return;
                
                // Play Korean audio
                if (card.koreanAudioUrl) {
                    await playAudioFile(card.koreanAudioUrl);
                }
                
                // Auto advance to next card
                if (isPlaying && currentIndex < currentCards.length - 1) {
                    await sleep(1000);
                    if (isPlaying) {
                        console.log('Auto advancing to next card');
                        autoNextCard();
                        await playBasicMode();
                    }
                } else {
                    console.log('Reached end of cards or playback stopped');
                    stopPlayback();
                    // Auto-advance to next sequence
                    await autoAdvanceToNextSequence();
                }
            } catch (error) {
                console.error('Error in basic mode playback:', error);
                stopPlayback();
            }
        }

        async function playExpressionMode() {
            const card = currentCards[currentIndex];
            
            try {
                // Play Japanese audio
                if (card.audioUrl) {
                    await playAudioFile(card.audioUrl);
                }
                
                if (!isPlaying) return;
                
                // Wait 3 seconds
                await sleep(3000);
                
                if (!isPlaying) return;
                
                // Play Korean audio
                if (card.koreanAudioUrl) {
                    await playAudioFile(card.koreanAudioUrl);
                }
                
                if (!isPlaying) return;
                
                // Load and play expressions
                await loadAndPlayExpressions(card);
                
                // Auto advance to next card
                if (isPlaying && currentIndex < currentCards.length - 1) {
                    await sleep(1000);
                    if (isPlaying) {
                        console.log('Auto advancing to next card (expression mode)');
                        autoNextCard();
                        await playExpressionMode();
                    }
                } else {
                    console.log('Reached end of cards or playback stopped (expression mode)');
                    stopPlayback();
                    // Auto-advance to next sequence
                    await autoAdvanceToNextSequence();
                }
            } catch (error) {
                console.error('Error in expression mode playback:', error);
                stopPlayback();
            }
        }

        async function loadAndPlayExpressions(card) {
            if (!card.expressionCardIds || card.expressionCardIds.length === 0) {
                return;
            }
            
            // Load expressions if not already loaded
            if (!card.expressions) {
                card.expressions = [];
                
                for (const expressionId of card.expressionCardIds) {
                    try {
                        const response = await fetch(`/api/expression/${expressionId}`);
                        if (response.ok) {
                            const expressionData = await response.json();
                            
                            const transformedExpression = {
                                mainExpression: expressionData.title,
                                examples: []
                            };
                            
                            // Add examples
                            for (let j = 1; j <= 5; j++) {
                                const japaneseExample = expressionData[`application${j}`];
                                const koreanExample = expressionData[`application${j}Korean`];
                                
                                if (japaneseExample && koreanExample) {
                                    transformedExpression.examples.push({
                                        japanese: japaneseExample,
                                        korean: koreanExample
                                    });
                                }
                            }
                            
                            card.expressions.push(transformedExpression);
                        }
                    } catch (error) {
                        console.error(`Error loading expression ${expressionId}:`, error);
                    }
                }
            }
            
            // Play expressions
            if (card.expressions && card.expressions.length > 0) {
                for (const expr of card.expressions) {
                    if (!isPlaying) break;
                    
                    // Play examples
                    if (expr.examples && expr.examples.length > 0) {
                        for (const example of expr.examples) {
                            if (!isPlaying) break;
                            
                            // Play Japanese example
                            if (example.japanese) {
                                await playTTSAudio(example.japanese, 'ja');
                            }
                            
                            if (!isPlaying) break;
                            
                            // Wait 2 seconds
                            await sleep(2000);
                            
                            if (!isPlaying) break;
                            
                            // Play Korean example
                            if (example.korean) {
                                await playTTSAudio(example.korean, 'ko');
                            }
                            
                            if (!isPlaying) break;
                            
                            await sleep(1000);
                        }
                    }
                }
            }
        }

        function playAudioFile(url) {
            return new Promise((resolve) => {
                if (!isPlaying) {
                    resolve();
                    return;
                }
                
                const audio = new Audio(url);
                currentAudio = audio;
                
                audio.onended = () => {
                    currentAudio = null;
                    resolve();
                };
                
                audio.onerror = () => {
                    console.error('Audio playback error:', url);
                    currentAudio = null;
                    resolve();
                };
                
                audio.play().catch(error => {
                    console.error('Audio play error:', error);
                    currentAudio = null;
                    resolve();
                });
            });
        }

        function playTTSAudio(text, language) {
            return new Promise((resolve) => {
                if (!window.speechSynthesis || !isPlaying) {
                    resolve();
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = language === 'ko' ? 'ko-KR' : 'ja-JP';
                utterance.rate = 1.2;
                
                const voices = window.speechSynthesis.getVoices();
                if (voices.length > 0) {
                    const targetVoice = voices.find(voice => 
                        voice.lang.startsWith(language === 'ko' ? 'ko' : 'ja')
                    );
                    if (targetVoice) {
                        utterance.voice = targetVoice;
                    }
                }
                
                utterance.onend = () => resolve();
                utterance.onerror = () => resolve();
                
                window.speechSynthesis.speak(utterance);
            });
        }

        function sleep(ms) {
            return new Promise(resolve => {
                if (!isPlaying) {
                    resolve();
                    return;
                }
                playbackTimeout = setTimeout(resolve, ms);
            });
        }

        function previousCard() {
            if (currentIndex > 0) {
                const wasPlaying = isPlaying;
                // Stop current playback when changing cards
                stopPlayback();
                displayCard(currentIndex - 1);
                // If it was playing, restart playback for new card
                if (wasPlaying) {
                    setTimeout(() => {
                        startPlayback();
                    }, 100);
                }
            }
        }

        function nextCard() {
            if (currentIndex < currentCards.length - 1) {
                const wasPlaying = isPlaying;
                // Stop current playback when changing cards
                stopPlayback();
                displayCard(currentIndex + 1);
                // If it was playing, restart playback for new card
                if (wasPlaying) {
                    setTimeout(() => {
                        startPlayback();
                    }, 100);
                }
            }
        }

        function autoNextCard() {
            if (currentIndex < currentCards.length - 1) {
                // Don't stop playback for auto-advance
                isAutoAdvancing = true;
                displayCard(currentIndex + 1);
                isAutoAdvancing = false;
            }
        }

        function goBack() {
            window.history.back();
        }

        async function autoAdvanceToNextSequence() {
            try {
                const currentSequenceNumber = parseInt(currentSequence.replace('#', ''));
                const nextSequenceNumber = currentSequenceNumber + 1;
                const nextSequence = `#${nextSequenceNumber.toString().padStart(3, '0')}`;
                
                console.log(`Auto-advancing from ${currentSequence} to ${nextSequence}`);
                
                // Check if next sequence has cards
                const response = await fetch('/api/flashcards');
                const data = await response.json();
                
                let hasNextSequence = false;
                if (Array.isArray(data)) {
                    hasNextSequence = data.some(card => card.sequence === nextSequence);
                } else if (data && typeof data === 'object') {
                    hasNextSequence = data[nextSequence] && data[nextSequence].length > 0;
                }
                
                if (hasNextSequence) {
                    // Navigate to next sequence
                    console.log(`Navigating to next sequence: ${nextSequence}`);
                    window.location.href = `player.html?sequence=${encodeURIComponent(nextSequence)}&mode=${currentMode}`;
                } else {
                    console.log('No more sequences available');
                    // Could add a completion message or navigate back to home
                    setTimeout(() => {
                        alert('모든 시퀀스를 완료했습니다!');
                        window.location.href = '/';
                    }, 1000);
                }
            } catch (error) {
                console.error('Error in autoAdvanceToNextSequence:', error);
                // Silently fail - just don't advance
            }
        }
    </script>
</body>
</html>