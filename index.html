<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Japanese Learning Flashcards</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 20px 20px 20px;
        }

        .app-container {
            width: 100%;
            max-width: 400px;
            text-align: center;
            padding: 0 1rem;
        }

        .app-title {
            color: white;
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            margin-top: 0.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .episode-nav {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            gap: 0.5rem;
        }

        .volume-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .volume-nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: rgba(255, 255, 255, 0.9);
        }

        .volume-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .volume-title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.3rem;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            min-width: 120px;
        }

        .sequence-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .sequence-nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: rgba(255, 255, 255, 0.9);
        }

        .sequence-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .sequence-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .episode-title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
            font-weight: 400;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .volume-text {
            font-size: 1.1rem;
            font-weight: 400;
        }
        
        .sequence-text {
            color: white;
            font-size: 1.0rem;
            font-weight: 300;
            min-width: 50px;
            text-align: center;
        }
        
        .sequence-nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .sequence-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .sequence-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .db-status-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
            pointer-events: none;
        }
        
        .db-connection-status {
            background: #F1F8E9;
            color: #555;
            padding: 6px 12px;
            border-radius: 15px;
            border: 0.25px solid #E0E0E0;
            font-size: 1.05rem;
            font-weight: 400;
            display: none;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(5px);
            width: fit-content;
            pointer-events: auto;
        }
        
        .db-connection-status.clickable {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .db-connection-status.clickable:hover {
            background: #E8F5E8;
        }
        
        .db-n1-status-container {
            display: flex;
            flex-direction: row;
            gap: 5px;
            margin-bottom: 5px;
            flex-wrap: wrap;
        }
        
        .db-n1-status {
            background: #F3F9FF;
            width: fit-content;
        }

        /* Expression Card Modal Styles */
        .expression-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }

        .expression-modal-content {
            background: white;
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            padding: 20px 16px; /* Ï¢åÏö∞ Ïó¨Î∞±ÏùÑ 30pxÏóêÏÑú 16pxÎ°ú Ï§ÑÏûÑ */
            max-width: 600px;
            width: 100%;
            max-height: 85vh;
            overflow-y: visible;
            position: relative;
            height: fit-content;
        }

        .expression-modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 5px;
        }

        .expression-modal-close:hover {
            color: #000;
        }

        .expression-main-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .expression-main-title {
            font-size: 25.6px; /* 32pxÏùò 80% */
            font-weight: bold;
            color: #1a1a1a;
            margin-bottom: 8px;
            cursor: pointer;
            transition: color 0.3s;
        }

        .expression-main-title:hover {
            color: #3b82f6;
        }

        .expression-main-meaning {
            font-size: 18px;
            color: #666;
        }

        .expression-applications {
            display: flex;
            flex-direction: column;
            gap: 4px; /* ÏòàÎ¨∏ Í∞Ñ Í∞ÑÍ≤©ÏùÑ 8pxÏóêÏÑú 4pxÎ°ú Ï§ÑÏûÑ */
        }

        .expression-application-item {
            border-left: 4px solid #c084fc;
            padding: 6px 8px; /* ÏúÑÏïÑÎûò Ïó¨Î∞±ÏùÑ 12pxÏóêÏÑú 6pxÎ°ú Ï§ÑÏûÑ */
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 0 8px 8px 0;
        }

        .expression-application-item:hover {
            background-color: #f9fafb;
        }

        .expression-application-japanese {
            font-size: 18px; /* 20pxÏóêÏÑú 1Îã®Í≥Ñ Í∞êÏÜå */
            font-weight: bold;
            color: #1a1a1a;
            margin-bottom: 2px; /* ÏùºÎ≥∏Ïñ¥ÏôÄ ÌïúÍµ≠Ïñ¥ Í∞Ñ Í∞ÑÍ≤©ÏùÑ 4pxÏóêÏÑú 2pxÎ°ú Ï§ÑÏûÑ */
        }

        .expression-application-korean {
            font-size: 14px;
            color: #6b7280;
        }

        .expression-loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        /* Word Card Modal Styles */
        .word-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }

        .word-modal-content {
            background: white;
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            padding: 20px 16px 16px 16px;
            max-width: 600px;
            width: 100%;
            max-height: 85vh;
            overflow-y: visible;
            position: relative;
            height: fit-content;
        }



        .word-main-section {
            text-align: center;
            margin-bottom: 0px;
        }

        .word-examples:hover {
            background: rgba(0,0,0,0.08) !important;
        }

        .word-main-title {
            font-size: 28px;
            font-weight: bold;
            color: #1a1a1a;
            margin-bottom: 8px;
            cursor: pointer;
            transition: color 0.3s;
        }

        .word-main-title:hover {
            color: #3b82f6;
        }

        .word-main-reading {
            font-size: 18px;
            color: #666;
            margin-bottom: 8px;
        }

        .word-main-meaning {
            font-size: 16px;
            color: #888;
        }

        .word-sentence-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e5e5e5;
        }

        .word-sentence-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 12px;
            text-align: center;
        }

        .word-sentence-item {
            border-left: 4px solid #48bb78;
            padding: 6px 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 0 8px 8px 0;
            margin-bottom: 8px;
        }

        .word-sentence-item:hover {
            background-color: #f0f9ff;
        }

        .word-sentence-japanese {
            font-size: 18px;
            font-weight: bold;
            color: #1a1a1a;
            margin-bottom: 2px;
        }

        .word-sentence-korean {
            font-size: 14px;
            color: #6b7280;
        }

        .db-status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #C8E6C9;
        }
        
        .db-n1-status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #81D4FA;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .episode-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
        }

        .episode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .episode-icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .flashcard-container {
            perspective: 1000px;
            margin-bottom: 2rem;
        }

        .flashcard {
            width: 100%;
            aspect-ratio: 3/4;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0.2, 0.2, 1);
            cursor: pointer;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 2rem;
            background: white;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            box-sizing: border-box;
        }

        .card-front {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9ff 100%);
        }

        .card-back {
            background: white;
            transform: rotateY(180deg);
        }

        .japanese-text {
            font-size: 1.4rem;
            font-weight: 500;
            color: #2d3748;
            line-height: 1.6;
            margin-bottom: 1rem;
            text-align: center;
        }

        .korean-text {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.5;
            text-align: center;
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        .speaker-btn {
            background: #4299e1;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            font-size: 1rem;
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            box-shadow: 0 2px 8px rgba(66, 153, 225, 0.3);
            z-index: 10;
        }

        .speaker-btn:hover {
            background: #3182ce;
            transform: scale(1.05);
        }

        .speaker-btn:active {
            transform: scale(0.95);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            color: white;
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .card-counter {
            color: white;
            font-size: 1rem;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .flip-instruction {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            margin-top: 1rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .speaker-icon {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        .speaker-btn {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            background: #4299e1;
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .word-speaker-btn {
            display: none;
        }

        .speaker-btn:hover {
            background: #3182ce;
            transform: scale(1.05);
        }



        .nav-icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .card-clickable-area {
            height: 80%;
            cursor: pointer;
        }
        
        .character-avatar {
            width: 128px;
            height: 128px;
            border-radius: 50%;
            background: transparent;
            margin: 1.5rem auto 2rem auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            border: 1px solid rgba(128, 128, 128, 0.3);
            overflow: hidden;
            flex-shrink: 0;
            position: relative;
        }

        .character-avatar img {
            width: 128px;
            height: 128px;
            object-fit: cover;
            border-radius: 50%;
            position: absolute;
            top: -1px;
            left: -1px;
        }

        .speaker-name {
            display: none;
        }

        /* Mobile optimizations */
        @media (max-width: 480px) {
            body {
                padding: 0;
                justify-content: flex-start;
                align-items: stretch;
                min-height: 100vh;
            }
            
            .app-container {
                padding: 0.5rem;
                margin-top: 0;
                height: 100vh;
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
            }
            
            .app-title {
                font-size: 1.5rem;
                margin-top: 0;
                margin-bottom: 0;
                display: none;
            }
            
            .episode-nav {
                margin-bottom: 0.5rem;
                margin-top: 0.5rem;
            }
            
            .episode-title {
                margin-bottom: 0;
            }

            .flashcard {
                aspect-ratio: 3/4;
                width: calc(100% - 2rem);
                margin: 0 auto;
            }

            .card-face {
                padding: 1rem;
            }

            .japanese-text {
                font-size: 1.32rem;
                line-height: 1.4;
                margin-bottom: 0.75rem;
            }

            .korean-text {
                font-size: 0.95rem;
                margin-top: 0.5rem;
            }
            
            .speaker-btn {
                width: 3.5rem;
                height: 3.5rem;
                bottom: 0.75rem;
                right: 0.75rem;
                font-size: 1.2rem;
            }
            
            .word-speaker-btn {
                width: 3.5rem;
                height: 3.5rem;
                bottom: 0.75rem;
                left: 0.75rem;
                font-size: 1.2rem;
            }
            
            .speaker-icon {
                width: 28px;
                height: 28px;
            }
            
            .character-avatar {
                width: 96px;
                height: 96px;
                margin-bottom: 0.75rem;
                font-size: 3.2rem;
            }
            
            .character-avatar img {
                width: 96px;
                height: 96px;
            }
            
            .speaker-name {
                font-size: 1.1rem;
                margin-bottom: 1rem;
            }

            .nav-btn {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            .controls {
                margin-top: 1rem;
            }
            
            .flashcard-container {
                margin-bottom: 1rem;
            }
        }

        /* Touch improvements */
        @media (hover: none) and (pointer: coarse) {
            .flashcard {
                -webkit-tap-highlight-color: transparent;
            }

            .speaker-btn:hover {
                transform: none;
                background: #4299e1;
            }

            .nav-btn:hover {
                transform: none;
                background: rgba(255, 255, 255, 0.2);
                border-color: rgba(255, 255, 255, 0.3);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="episode-nav">
            <div class="volume-navigation">
                <button class="volume-nav-btn" onclick="previousVolume()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                    </svg>
                </button>
                <span class="volume-title">PALM 26Í∂å</span>
                <button class="volume-nav-btn" onclick="nextVolume()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                    </svg>
                </button>
            </div>
            <div class="sequence-navigation">
                <button class="sequence-nav-btn" id="prev-sequence-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                    </svg>
                </button>
                <span class="sequence-text" id="sequence-text">#001</span>
                <button class="sequence-nav-btn" id="next-sequence-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="flashcard-container">
            <div class="flashcard" id="flashcard">
                <div class="card-face card-front">
                    <div class="card-clickable-area" onclick="flipCard()">
                        <div class="character-avatar" id="character-avatar"></div>
                        <div class="speaker-name" id="speaker-name"></div>
                        <div class="japanese-text" id="japanese-text"></div>
                    </div>
                    <button class="speaker-btn" id="speaker-btn" title="Listen to pronunciation">
                        <svg class="speaker-icon" viewBox="0 0 24 24">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                        </svg>
                    </button>
                    <button class="word-speaker-btn" id="word-speaker-btn" title="Listen to word pronunciation">
                        <svg class="speaker-icon" viewBox="0 0 24 24">
                            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                        </svg>
                    </button>
                    <div class="db-status-container" id="db-status-container-front">
                        <div class="db-n1-status-container" id="db-n1-status-container-front">
                            <!-- Multiple N1 vocabulary items will be inserted here -->
                        </div>
                        <div class="db-connection-status" id="db-status-front">
                            <div class="db-status-dot"></div>
                            <span id="db-status-text-front"></span>
                        </div>
                    </div>
                </div>
                <div class="card-face card-back">
                    <div class="card-clickable-area" onclick="flipCard()">
                        <div class="character-avatar" id="character-avatar-back"></div>
                        <div class="japanese-text" id="japanese-text-back"></div>
                        <div class="korean-text" id="korean-text"></div>
                    </div>
                    <button class="speaker-btn" id="speaker-btn-back" title="Listen to pronunciation">
                        <svg class="speaker-icon" viewBox="0 0 24 24">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                        </svg>
                    </button>
                    <button class="word-speaker-btn" id="word-speaker-btn-back" title="Listen to word pronunciation">
                        <svg class="speaker-icon" viewBox="0 0 24 24">
                            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                        </svg>
                    </button>
                    <div class="db-status-container" id="db-status-container-back">
                        <div class="db-n1-status-container" id="db-n1-status-container-back">
                            <!-- Multiple N1 vocabulary items will be inserted here -->
                        </div>
                        <div class="db-connection-status" id="db-status-back">
                            <div class="db-status-dot"></div>
                            <span id="db-status-text-back"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="nav-btn" id="prev-btn">
                <svg class="nav-icon" viewBox="0 0 24 24">
                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                </svg>
            </button>
            <div class="card-counter">
                <span id="current-card">1</span> / <span id="total-cards">3</span>
            </div>
            <button class="nav-btn" id="next-btn">
                <svg class="nav-icon" viewBox="0 0 24 24">
                    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                </svg>
            </button>
        </div>
    </div>

    <script>
        // Flashcard data - will be loaded from Notion
        let flashcards = [];

        let currentCardIndex = 0;
        let isFlipped = false;

        // DOM elements
        const flashcard = document.getElementById('flashcard');
        const japaneseText = document.getElementById('japanese-text');
        const japaneseTextBack = document.getElementById('japanese-text-back');
        const koreanText = document.getElementById('korean-text');
        const characterAvatar = document.getElementById('character-avatar');
        const characterAvatarBack = document.getElementById('character-avatar-back');
        const speakerName = document.getElementById('speaker-name');
        const speakerBtn = document.getElementById('speaker-btn');
        const speakerBtnBack = document.getElementById('speaker-btn-back');
        const wordSpeakerBtn = document.getElementById('word-speaker-btn');
        const wordSpeakerBtnBack = document.getElementById('word-speaker-btn-back');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const currentCardSpan = document.getElementById('current-card');
        const totalCardsSpan = document.getElementById('total-cards');
        const episodeTitle = document.getElementById('episode-title');
        // Remove unused episode buttons that were deleted from HTML
        const prevSequenceBtn = document.getElementById('prev-sequence-btn');
        const nextSequenceBtn = document.getElementById('next-sequence-btn');
        const dbStatusFront = document.getElementById('db-status-front');
        const dbStatusBack = document.getElementById('db-status-back');
        const dbStatusTextFront = document.getElementById('db-status-text-front');
        const dbStatusTextBack = document.getElementById('db-status-text-back');
        const dbN1StatusContainerFront = document.getElementById('db-n1-status-container-front');
        const dbN1StatusContainerBack = document.getElementById('db-n1-status-container-back');

        // Load flashcards from Notion
        async function loadFlashcardsFromNotion() {
            try {
                const response = await fetch('/api/flashcards');
                if (!response.ok) {
                    throw new Error('Failed to fetch flashcards');
                }
                const data = await response.json();
                flashcards = data;
                
                if (flashcards.length === 0) {
                    showError('ÎÖ∏ÏÖò Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÌîåÎûòÏãúÏπ¥ÎìúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
                    return;
                }
                
                init();
            } catch (error) {
                console.error('Error loading flashcards:', error);
                // Only show error if there's actually a fetch problem
                if (error.message.includes('fetch') || error.message.includes('Failed to fetch')) {
                    showError('ÎÖ∏ÏÖò Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
                }
            }
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #ff6b6b;
                color: white;
                padding: 20px;
                border-radius: 8px;
                text-align: center;
                z-index: 1000;
            `;
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
        }

        // Episode management
        let currentEpisode = 1;
        let episodeData = {};
        let currentEpisodeCards = [];
        let preloadedAudios = {}; // Store preloaded audio elements
        let preloadedExpressionCards = {}; // Store preloaded expression card data
        let preloadedN1WordData = {}; // Store preloaded N1 word data

        // Parse sequence data from flashcards
        function parseEpisodes() {
            episodeData = {};
            flashcards.forEach((card, index) => {
                // Group by sequence instead of episode
                const sequence = card.sequence || '#001';
                
                if (!episodeData[sequence]) {
                    episodeData[sequence] = [];
                }
                
                // Sort by romanji (sequence number)
                const sortOrder = parseInt(card.romanji) || (index + 1);
                episodeData[sequence].push({...card, sentenceNum: sortOrder});
            });
            
            // Sort sentences within each episode
            Object.keys(episodeData).forEach(ep => {
                episodeData[ep].sort((a, b) => a.sentenceNum - b.sentenceNum);
            });
            
            // Set current sequence to first available
            const availableSequences = Object.keys(episodeData).sort();
            if (availableSequences.length > 0) {
                currentEpisode = availableSequences[0]; // Use currentEpisode variable for sequence
                loadEpisode(currentEpisode);
            }
        }

        // Load cards for specific sequence
        function loadEpisode(sequenceName) {
            currentEpisode = sequenceName;
            currentEpisodeCards = episodeData[sequenceName] || [];
            currentCardIndex = 0;
            
            // Clear previous preloaded data when switching sequences
            preloadedAudios = {};
            preloadedExpressionCards = {};
            preloadedN1WordData = {};
            console.log('Cleared preloaded data for new sequence:', sequenceName);
            
            // Update title to show volume and sequence
            const firstCard = currentEpisodeCards[0];
            const volume = firstCard?.volume || '26Í∂å';
            
            // Update volume and sequence text
            const volumeText = document.querySelector('.volume-text');
            const sequenceText = document.querySelector('.sequence-text');
            if (volumeText) volumeText.textContent = volume;
            if (sequenceText) sequenceText.textContent = sequenceName;
            
            if (currentEpisodeCards.length > 0) {
                // Sort cards by sequence number (romanji) in ascending order
                currentEpisodeCards.sort((a, b) => {
                    const aNum = parseInt(a.romanji) || 0;
                    const bNum = parseInt(b.romanji) || 0;
                    return aNum - bNum; // Ascending order
                });
                
                loadCard(currentCardIndex);
                totalCardsSpan.textContent = currentEpisodeCards.length;
                updateNavigationButtons();
                updateEpisodeButtons();
                
                // Preload audio for current and next cards
                preloadAudio();
                
                // Aggressively preload current card data immediately
                preloadCurrentCardDataImmediately();
            }
        }

        // Update sequence navigation buttons
        function updateEpisodeButtons() {
            const sequences = Object.keys(episodeData).sort();
            const currentIndex = sequences.indexOf(currentEpisode);
            
            // Update sequence navigation buttons
            if (prevSequenceBtn) {
                prevSequenceBtn.disabled = currentIndex <= 0;
            }
            if (nextSequenceBtn) {
                nextSequenceBtn.disabled = currentIndex >= sequences.length - 1;
            }
            
            // Episode buttons have been removed from HTML
        }

        // Get diverse emoji based on sentence index and content
        function getEmojiForSentence(japanese, cardIndex = 0) {
            // Wide variety of emojis to ensure diversity
            const emojiPool = [
                'üòä', 'üòÑ', 'üòÉ', 'üòÄ', 'üòÅ', 'üôÇ', 'üòá', 'üòÜ', 'ü§£', 'üòÇ',
                'ü•∞', 'üòç', 'ü§©', 'üòã', 'üòú', 'ü§™', 'üòé', 'ü§ì', 'ü•≥', 'üòå',
                'üòâ', 'üòè', 'üôÉ', 'üòó', 'üòô', 'üòö', 'ü§ó', 'ü§≠', 'ü§´', 'ü§®',
                'üòê', 'üòë', 'üôÑ', 'üò∂', 'üòØ', 'üòÆ', 'üò≤', 'üòµ', 'ü§Ø', 'ü•¥',
                'ü§î', 'ü§ê', 'ü§•', 'üò¥', 'üò™', 'ü•±', 'üòî', 'üòü', 'üòï', 'üôÅ',
                '‚òπÔ∏è', 'üò£', 'üòñ', 'üò´', 'üò©', 'ü•∫', 'üò¢', 'üò≠', 'üò§', 'üò†',
                'üò°', 'ü§¨', 'ü§Ø', 'üò≥', 'ü•µ', 'ü•∂', 'üò±', 'üò®', 'üò∞', 'üò•',
                'üòì', 'ü§ó', 'ü§¢', 'ü§Æ', 'ü§ß', 'üò∑', 'ü§í', 'ü§ï', 'ü§†', 'üòà',
                'üëø', 'üëπ', 'üë∫', 'ü§°', 'üí©', 'üëª', 'üíÄ', '‚ò†Ô∏è', 'üëΩ', 'üëæ',
                'ü§ñ', 'üé≠', 'üíù', 'üíñ', 'üíó', 'üíì', 'üíû', 'üíï', 'üíü', '‚ù£Ô∏è',
                'üíî', '‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é',
                'üíã', 'üíØ', 'üí¢', 'üí•', 'üí´', 'üí¶', 'üí®', 'üï≥Ô∏è', 'üí£', 'üí¨',
                'üëÅÔ∏è', 'üó®Ô∏è', 'üóØÔ∏è', 'üí≠', 'üí§', 'üëã', 'ü§ö', 'üñêÔ∏è', '‚úã', 'üññ',
                'üëå', 'ü§å', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ',
                'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', 'üëç', 'üëé', 'üëä', '‚úä', 'ü§õ', 'ü§ú'
            ];
            
            // Use card index to ensure variety across consecutive cards
            let baseIndex = cardIndex % emojiPool.length;
            
            // Add some randomness based on text content
            const textHash = japanese.split('').reduce((hash, char) => {
                return ((hash << 5) - hash + char.charCodeAt(0)) & 0xffffffff;
            }, 0);
            
            const finalIndex = (baseIndex + Math.abs(textHash) % 20) % emojiPool.length;
            
            // Still check for specific emotional content to override with appropriate emojis
            const text = japanese.toLowerCase();
            
            if (text.includes('Ôºü') || text.includes('?')) {
                const questionEmojis = ['‚ùì', '‚ùî', 'ü§î', 'üßê', 'üí≠', 'ü§∑', 'üôã'];
                return questionEmojis[Math.abs(textHash) % questionEmojis.length];
            }
            
            if (text.includes('„ÅÇ„Çä„Åå„Å®„ÅÜ') || text.includes('ÊÑüË¨ù')) {
                const thankfulEmojis = ['üòä', 'üôè', 'üòá', 'ü•∞', 'üòç', 'üíñ', '‚ú®'];
                return thankfulEmojis[Math.abs(textHash) % thankfulEmojis.length];
            }
            
            if (text.includes('„Åô„Åø„Åæ„Åõ„Çì') || text.includes('„Åî„ÇÅ„Çì')) {
                const sorryEmojis = ['üòÖ', 'üòì', 'üôá', 'üòî', 'üòû', 'ü•∫', 'üò∞'];
                return sorryEmojis[Math.abs(textHash) % sorryEmojis.length];
            }
            
            if (text.includes('„ÅÜ„Çå„Åó„ÅÑ') || text.includes('Ê•Ω„Åó„ÅÑ') || text.includes('„Çà„Åã„Å£„Åü')) {
                const happyEmojis = ['üòÑ', 'üòÅ', 'ü•≥', 'üòÜ', 'ü§©', '‚ú®', 'üéâ', 'üíÉ'];
                return happyEmojis[Math.abs(textHash) % happyEmojis.length];
            }
            
            if (text.includes('ÊÇ≤„Åó„ÅÑ') || text.includes('„Å§„Çâ„ÅÑ')) {
                const sadEmojis = ['üò¢', 'üò≠', 'üòî', 'üòû', 'ü•∫', 'üíî', 'üòø'];
                return sadEmojis[Math.abs(textHash) % sadEmojis.length];
            }
            
            if (text.includes('È£ü„Åπ') || text.includes('È£≤„Åø') || text.includes('ÁæéÂë≥')) {
                const foodEmojis = ['üòã', 'ü§§', 'üçΩÔ∏è', 'ü•¢', 'üçú', 'üç±', 'üçî', 'ü•ó'];
                return foodEmojis[Math.abs(textHash) % foodEmojis.length];
            }
            
            if (text.includes('ÂãâÂº∑') || text.includes('Â≠¶') || text.includes('Ë™≠')) {
                const studyEmojis = ['üìö', '‚úèÔ∏è', 'üìù', 'üéì', 'ü§ì', 'üí°', 'üìñ', '‚úçÔ∏è'];
                return studyEmojis[Math.abs(textHash) % studyEmojis.length];
            }
            
            if (text.includes('‰ªï‰∫ã') || text.includes('ÂÉç')) {
                const workEmojis = ['üíº', 'üíª', 'üìä', '‚ö°', 'üéØ', 'üìà', 'üè¢', '‚è∞'];
                return workEmojis[Math.abs(textHash) % workEmojis.length];
            }
            
            // Return emoji from the diverse pool
            return emojiPool[finalIndex];
        }

        // Initialize the app
        function init() {
            parseEpisodes();
        }

        // Load a specific card
        function loadCard(index) {
            if (index < 0 || index >= currentEpisodeCards.length) return;
            
            const card = currentEpisodeCards[index];
            japaneseText.textContent = card.japanese;
            japaneseTextBack.textContent = card.japanese;
            koreanText.textContent = card.korean;
            speakerName.textContent = "";
            currentCardSpan.textContent = index + 1;
            
            // Set character avatar for both front and back - use image if available, otherwise emoji based on sentence mood
            if (card.characterImage) {
                console.log('Character image URL:', card.characterImage);
                
                // Create image elements with error handling
                const frontImg = document.createElement('img');
                frontImg.src = card.characterImage;
                frontImg.alt = card.speaker || 'Character';
                frontImg.style.width = '100%';
                frontImg.style.height = '100%';
                frontImg.style.objectFit = 'cover';
                frontImg.style.borderRadius = '50%';
                
                const backImg = document.createElement('img');
                backImg.src = card.characterImage;
                backImg.alt = card.speaker || 'Character';
                backImg.style.width = '100%';
                backImg.style.height = '100%';
                backImg.style.objectFit = 'cover';
                backImg.style.borderRadius = '50%';
                
                // Add error handling - fallback to emoji if image fails to load
                const fallbackEmoji = getEmojiForSentence(card.japanese, index);
                
                frontImg.onload = () => {
                    console.log('Character image loaded successfully');
                };
                
                frontImg.onerror = () => {
                    console.log('Failed to load character image, using emoji fallback');
                    characterAvatar.textContent = fallbackEmoji;
                    characterAvatar.innerHTML = '';
                };
                
                backImg.onload = () => {
                    console.log('Character image loaded successfully (back)');
                };
                
                backImg.onerror = () => {
                    console.log('Failed to load character image, using emoji fallback (back)');
                    characterAvatarBack.textContent = fallbackEmoji;
                    characterAvatarBack.innerHTML = '';
                };
                
                // Clear previous content and add image
                characterAvatar.innerHTML = '';
                characterAvatar.textContent = '';
                characterAvatar.appendChild(frontImg);
                
                characterAvatarBack.innerHTML = '';
                characterAvatarBack.textContent = '';
                characterAvatarBack.appendChild(backImg);
            } else {
                const emoji = getEmojiForSentence(card.japanese, index);
                characterAvatar.innerHTML = '';
                characterAvatar.textContent = emoji;
                characterAvatarBack.innerHTML = '';
                characterAvatarBack.textContent = emoji;
            }
            
            // Update database connection status
            updateDBStatus(card);
            
            // Reset flip state
            if (isFlipped) {
                flipCard();
            }
        }
        
        // Update database connection status based on card data
        async function updateDBStatus(card) {
            // Reset all status displays
            if (dbStatusFront) {
                dbStatusFront.style.display = 'none';
                dbStatusFront.classList.remove('clickable');
                if (dbStatusFront.clickHandler) {
                    dbStatusFront.removeEventListener('click', dbStatusFront.clickHandler);
                }
            }
            if (dbStatusBack) {
                dbStatusBack.style.display = 'none';
                dbStatusBack.classList.remove('clickable');
                if (dbStatusBack.clickHandler) {
                    dbStatusBack.removeEventListener('click', dbStatusBack.clickHandler);
                }
            }
            if (dbN1StatusContainerFront) dbN1StatusContainerFront.innerHTML = '';
            if (dbN1StatusContainerBack) dbN1StatusContainerBack.innerHTML = '';
            
            // Check if card has expression card relations (multiple possible)
            if (card.expressionCardIds && card.expressionCardIds.length > 0) {
                try {
                    console.log('Processing expression cards:', card.expressionCardIds);
                    
                    // Fetch all expression cards
                    const expressionPromises = card.expressionCardIds.map(id => 
                        fetch(`/api/expression-card/${id}`).then(res => res.json())
                    );
                    
                    const expressionCards = await Promise.all(expressionPromises);
                    console.log('Fetched expression cards:', expressionCards);
                    
                    expressionCards.forEach((expressionCard, index) => {
                        if (expressionCard && expressionCard.title) {
                            const expressionId = card.expressionCardIds[index];
                            console.log(`Processing expression card ${index + 1}/${expressionCards.length}:`, expressionCard.title);
                            
                            if (index === 0) {
                                // For the first expression, use the main db-status elements
                                if (dbStatusFront) {
                                    dbStatusFront.style.display = 'flex';
                                    dbStatusFront.classList.add('clickable');
                                    if (dbStatusTextFront) dbStatusTextFront.textContent = expressionCard.title;
                                    
                                    dbStatusFront.removeEventListener('click', dbStatusFront.clickHandler);
                                    dbStatusFront.clickHandler = (e) => {
                                        e.stopPropagation();
                                        openExpressionModal(expressionId);
                                    };
                                    dbStatusFront.addEventListener('click', dbStatusFront.clickHandler);
                                }
                                if (dbStatusBack) {
                                    dbStatusBack.style.display = 'flex';
                                    dbStatusBack.classList.add('clickable');
                                    if (dbStatusTextBack) dbStatusTextBack.textContent = expressionCard.title;
                                    
                                    dbStatusBack.removeEventListener('click', dbStatusBack.clickHandler);
                                    dbStatusBack.clickHandler = (e) => {
                                        e.stopPropagation();
                                        openExpressionModal(expressionId);
                                    };
                                    dbStatusBack.addEventListener('click', dbStatusBack.clickHandler);
                                }
                            } else {
                                // For additional expressions, create new elements
                                console.log('Creating additional expression element for:', expressionCard.title);
                                
                                // Create front expression item with exact same styling as original
                                const frontItem = document.createElement('div');
                                frontItem.className = 'db-connection-status clickable';
                                
                                const frontDot = document.createElement('div');
                                frontDot.className = 'db-status-dot';
                                frontItem.appendChild(frontDot);
                                
                                const frontText = document.createElement('span');
                                frontText.textContent = expressionCard.title;
                                frontItem.appendChild(frontText);
                                
                                // Add click handler
                                frontItem.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    openExpressionModal(expressionId);
                                });
                                
                                // Create back expression item with exact same styling as original
                                const backItem = document.createElement('div');
                                backItem.className = 'db-connection-status clickable';
                                
                                const backDot = document.createElement('div');
                                backDot.className = 'db-status-dot';
                                backItem.appendChild(backDot);
                                
                                const backText = document.createElement('span');
                                backText.textContent = expressionCard.title;
                                backItem.appendChild(backText);
                                
                                // Add click handler
                                backItem.addEventListener('click', (e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    openExpressionModal(expressionId);
                                });
                                
                                // Add to expression containers - use parent containers
                                const frontParent = dbStatusFront?.parentElement;
                                const backParent = dbStatusBack?.parentElement;
                                
                                if (frontParent) {
                                    frontParent.appendChild(frontItem);
                                    console.log('Added front expression item to parent');
                                }
                                if (backParent) {
                                    backParent.appendChild(backItem);
                                    console.log('Added back expression item to parent');
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('Error fetching expression card info:', error);
                }
            }
            
            // Check if card has N1 vocabulary relations (multiple possible)
            if (card.n1VocabularyIds && card.n1VocabularyIds.length > 0) {
                try {
                    const response = await fetch(`/api/n1-vocabulary-multiple/${card.n1VocabularyIds.join(',')}`);
                    const n1Vocabularies = await response.json();
                    
                    if (n1Vocabularies && n1Vocabularies.length > 0) {
                        // Create N1 vocabulary status items for each word
                        n1Vocabularies.forEach(vocabulary => {
                            if (vocabulary && vocabulary.word) {
                                // Create elements for front
                                const frontStatusItem = document.createElement('div');
                                frontStatusItem.className = 'db-connection-status db-n1-status clickable';
                                frontStatusItem.style.display = 'flex';
                                frontStatusItem.style.cursor = 'pointer';
                                frontStatusItem.innerHTML = `
                                    <div class="db-n1-status-dot"></div>
                                    <span>${vocabulary.word}</span>
                                `;
                                frontStatusItem.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    openWordModalWithN1Data(vocabulary);
                                });
                                
                                // Create elements for back
                                const backStatusItem = document.createElement('div');
                                backStatusItem.className = 'db-connection-status db-n1-status clickable';
                                backStatusItem.style.display = 'flex';
                                backStatusItem.style.cursor = 'pointer';
                                backStatusItem.innerHTML = `
                                    <div class="db-n1-status-dot"></div>
                                    <span>${vocabulary.word}</span>
                                `;
                                backStatusItem.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    openWordModalWithN1Data(vocabulary);
                                });
                                
                                if (dbN1StatusContainerFront) dbN1StatusContainerFront.appendChild(frontStatusItem);
                                if (dbN1StatusContainerBack) dbN1StatusContainerBack.appendChild(backStatusItem);
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error fetching N1 vocabulary info:', error);
                }
            }
        }
        


        // Flip the card
        function flipCard() {
            flashcard.classList.toggle('flipped');
            isFlipped = !isFlipped;
        }

        // Text-to-speech functionality
        function speakJapanese() {
            console.log('=== speakJapanese function started ===');
            
            // Stop any ongoing audio
            if (window.currentAudio) {
                window.currentAudio.pause();
                window.currentAudio.currentTime = 0;
            }
            
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            console.log('Previous audio/speech cancelled');
            
            console.log('currentEpisodeCards:', currentEpisodeCards);
            console.log('currentCardIndex:', currentCardIndex);
            console.log('currentEpisodeCards length:', currentEpisodeCards ? currentEpisodeCards.length : 'undefined');
            
            if (!currentEpisodeCards || currentEpisodeCards.length === 0) {
                console.error('No episode cards available');
                return;
            }
            
            if (currentCardIndex < 0 || currentCardIndex >= currentEpisodeCards.length) {
                console.error('Invalid card index:', currentCardIndex);
                return;
            }
            
            const currentCard = currentEpisodeCards[currentCardIndex];
            console.log('Current card:', currentCard);
            console.log('Current card audioUrl:', currentCard.audioUrl);
            console.log('Current episode:', currentEpisode);
            console.log('Current card index:', currentCardIndex);
            console.log('Current card Japanese text:', currentCard.japanese);
            
            if (!currentCard) {
                console.error('Current card is null or undefined');
                return;
            }
            
            // Try to play MP3 file from Notion first
            if (currentCard.audioUrl) {
                console.log('Playing audio from Notion MP3:', currentCard.audioUrl);
                
                // Use preloaded audio if available
                const preloadedKey = `${currentEpisode}_${currentCardIndex}`;
                console.log('Looking for preloaded audio with key:', preloadedKey);
                console.log('Available preloaded keys:', Object.keys(preloadedAudios));
                const audio = preloadedAudios[preloadedKey] || new Audio(currentCard.audioUrl);
                console.log('Audio source URL:', audio.src);
                window.currentAudio = audio;
                
                // Visual feedback for playing
                speakerBtn.style.background = '#2b6cb0';
                speakerBtnBack.style.background = '#2b6cb0';
                
                audio.onended = () => {
                    speakerBtn.style.background = '#4299e1';
                    speakerBtnBack.style.background = '#4299e1';
                    console.log('Audio playback ended');
                };
                
                audio.onerror = (event) => {
                    speakerBtn.style.background = '#4299e1';
                    speakerBtnBack.style.background = '#4299e1';
                    console.warn('Audio playback error - no fallback');
                    console.error('Audio Error:', event);
                };
                
                // Start loading and play when ready (skip load if preloaded)
                if (!preloadedAudios[preloadedKey]) {
                    console.log('Audio not preloaded, loading now');
                    audio.load();
                } else {
                    console.log('Using preloaded audio');
                }
                audio.play().catch(error => {
                    console.error('Error playing audio:', error);
                    speakerBtn.style.background = '#4299e1';
                    speakerBtnBack.style.background = '#4299e1';
                });
                
                console.log('=== speakJapanese function ended (MP3 playback) ===');
                return;
            }
            
            // No audio URL found - no fallback
            console.log('No audio URL found - no audio will be played');
            console.log('=== speakJapanese function ended (no audio) ===');
        }

        // Preload audio and data for current and next cards
        function preloadAudio() {
            if (!currentEpisodeCards || currentEpisodeCards.length === 0) return;
            
            // Preload current card audio
            const currentCard = currentEpisodeCards[currentCardIndex];
            if (currentCard && currentCard.audioUrl) {
                const key = `${currentEpisode}_${currentCardIndex}`;
                if (!preloadedAudios[key]) {
                    console.log('Preloading audio for current card:', currentCard.japanese, 'Key:', key);
                    preloadedAudios[key] = new Audio(currentCard.audioUrl);
                    preloadedAudios[key].preload = 'auto';
                    preloadedAudios[key].load();
                }
            }
            
            // Preload next card audio if it exists
            if (currentCardIndex + 1 < currentEpisodeCards.length) {
                const nextCard = currentEpisodeCards[currentCardIndex + 1];
                if (nextCard && nextCard.audioUrl) {
                    const key = `${currentEpisode}_${currentCardIndex + 1}`;
                    if (!preloadedAudios[key]) {
                        console.log('Preloading audio for next card:', nextCard.japanese, 'Key:', key);
                        preloadedAudios[key] = new Audio(nextCard.audioUrl);
                        preloadedAudios[key].preload = 'auto';
                        preloadedAudios[key].load();
                    }
                }
            }
            
            // Preload expression card data for next card
            preloadNextCardData();
        }
        
        // Preload expression cards and N1 word data for current and next cards
        function preloadNextCardData() {
            // Preload current card data first
            const currentCard = currentEpisodeCards[currentCardIndex];
            const currentCardKey = `${currentEpisode}_${currentCardIndex}`;
            
            if (currentCard) {
                // Preload expression cards for current card
                if (currentCard.expressionCards && currentCard.expressionCards.length > 0) {
                    if (!preloadedExpressionCards[currentCardKey]) {
                        console.log('Preloading expression cards for current card:', currentCard.japanese);
                        preloadedExpressionCards[currentCardKey] = 'loading';
                        
                        // Fetch expression cards for current card
                        Promise.all(currentCard.expressionCards.map(id => 
                            fetch(`/api/expression-card/${id}`)
                                .then(response => response.json())
                                .catch(error => {
                                    console.error('Error preloading expression card:', error);
                                    return null;
                                })
                        )).then(results => {
                            preloadedExpressionCards[currentCardKey] = results.filter(r => r !== null);
                            console.log('Preloaded expression cards for current card:', preloadedExpressionCards[currentCardKey].length);
                        });
                    }
                }
                
                // Preload N1 word data for current card
                if (currentCard.n1VocabularyId) {
                    if (!preloadedN1WordData[currentCardKey]) {
                        console.log('Preloading N1 word data for current card:', currentCard.japanese);
                        preloadedN1WordData[currentCardKey] = 'loading';
                        
                        fetch(`/api/n1-vocabulary/${currentCard.n1VocabularyId}`)
                            .then(response => response.json())
                            .then(data => {
                                preloadedN1WordData[currentCardKey] = data;
                                console.log('Preloaded N1 word data for current card:', data?.word);
                            })
                            .catch(error => {
                                console.error('Error preloading N1 word data:', error);
                                preloadedN1WordData[currentCardKey] = null;
                            });
                    }
                }
            }
            
            // Then preload next card data
            if (currentCardIndex + 1 < currentEpisodeCards.length) {
                const nextCard = currentEpisodeCards[currentCardIndex + 1];
                const nextCardKey = `${currentEpisode}_${currentCardIndex + 1}`;
                
                // Preload expression cards for next card
                if (nextCard.expressionCards && nextCard.expressionCards.length > 0) {
                    if (!preloadedExpressionCards[nextCardKey]) {
                        console.log('Preloading expression cards for next card:', nextCard.japanese);
                        preloadedExpressionCards[nextCardKey] = 'loading';
                        
                        // Fetch expression cards for next card
                        Promise.all(nextCard.expressionCards.map(id => 
                            fetch(`/api/expression-card/${id}`)
                                .then(response => response.json())
                                .catch(error => {
                                    console.error('Error preloading expression card:', error);
                                    return null;
                                })
                        )).then(results => {
                            preloadedExpressionCards[nextCardKey] = results.filter(r => r !== null);
                            console.log('Preloaded expression cards for next card:', preloadedExpressionCards[nextCardKey].length);
                        });
                    }
                }
                
                // Preload N1 word data for next card
                if (nextCard.n1VocabularyId) {
                    if (!preloadedN1WordData[nextCardKey]) {
                        console.log('Preloading N1 word data for next card:', nextCard.japanese);
                        preloadedN1WordData[nextCardKey] = 'loading';
                        
                        fetch(`/api/n1-vocabulary/${nextCard.n1VocabularyId}`)
                            .then(response => response.json())
                            .then(data => {
                                preloadedN1WordData[nextCardKey] = data;
                                console.log('Preloaded N1 word data for next card:', data?.word);
                            })
                            .catch(error => {
                                console.error('Error preloading N1 word data:', error);
                                preloadedN1WordData[nextCardKey] = null;
                            });
                    }
                }
            }
        }
        
        // Aggressively preload current card data immediately when card is loaded
        function preloadCurrentCardDataImmediately() {
            const currentCard = currentEpisodeCards[currentCardIndex];
            if (!currentCard) return;
            
            const currentCardKey = `${currentEpisode}_${currentCardIndex}`;
            console.log('Aggressively preloading current card data:', currentCard.japanese);
            
            // Load expression cards immediately
            if (currentCard.expressionCards && currentCard.expressionCards.length > 0) {
                console.log('Loading expression cards immediately:', currentCard.expressionCards.length);
                Promise.all(currentCard.expressionCards.map(id => 
                    fetch(`/api/expression-card/${id}`)
                        .then(response => response.json())
                        .catch(error => {
                            console.error('Error loading expression card:', error);
                            return null;
                        })
                )).then(results => {
                    preloadedExpressionCards[currentCardKey] = results.filter(r => r !== null);
                    console.log('Immediately loaded expression cards:', preloadedExpressionCards[currentCardKey].length);
                });
            }
            
            // Load N1 word data immediately
            if (currentCard.n1VocabularyId) {
                console.log('Loading N1 word data immediately:', currentCard.n1VocabularyId);
                fetch(`/api/n1-vocabulary/${currentCard.n1VocabularyId}`)
                    .then(response => response.json())
                    .then(data => {
                        preloadedN1WordData[currentCardKey] = data;
                        console.log('Immediately loaded N1 word data:', data?.word);
                    })
                    .catch(error => {
                        console.error('Error loading N1 word data:', error);
                        preloadedN1WordData[currentCardKey] = null;
                    });
            }
        }

        // Fallback TTS function
        function speakJapaneseWithTTS() {
            console.log('=== speakJapaneseWithTTS function started ===');
            
            const currentCard = currentEpisodeCards[currentCardIndex];
            
            if (!currentCard.japanese) {
                console.error('No Japanese text in current card');
                return;
            }
            
            console.log('Speaking Japanese text with TTS:', currentCard.japanese);
            const utterance = new SpeechSynthesisUtterance(currentCard.japanese);
            console.log('TTS Utterance created');
            
            // Wait for voices to load on mobile browsers
            const voices = speechSynthesis.getVoices();
            console.log('Available voices count:', voices.length);
            
            if (voices.length === 0) {
                console.log('No voices available, waiting for voiceschanged event');
                // Retry after voices are loaded
                speechSynthesis.addEventListener('voiceschanged', () => {
                    console.log('Voices changed event triggered');
                    speakJapaneseWithTTS();
                }, { once: true });
                return;
            }
            
            // Find Japanese voice
            const selectedVoice = voices.find(voice => 
                voice.lang.startsWith('ja') || voice.name.includes('Japanese') || voice.name.includes('ja-')
            );
            
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            
            utterance.lang = 'ja-JP';
            
            // Visual feedback for speaking
            speakerBtn.style.background = '#2b6cb0';
            speakerBtnBack.style.background = '#2b6cb0';
            
            utterance.onend = () => {
                speakerBtn.style.background = '#4299e1';
                speakerBtnBack.style.background = '#4299e1';
            };
            
            utterance.onerror = (event) => {
                speakerBtn.style.background = '#4299e1';
                speakerBtnBack.style.background = '#4299e1';
                console.warn('Speech synthesis error - Japanese voice may not be available');
                console.error('TTS Error:', event);
                
                // Log available voices for debugging on mobile
                console.log('Available voices:', voices.map(v => `${v.name} (${v.lang})`));
            };
            
            console.log('About to speak with TTS utterance:', utterance);
            speechSynthesis.speak(utterance);
            console.log('speechSynthesis.speak() called');
            console.log('=== speakJapaneseWithTTS function ended ===');
        }

        // Text-to-speech for N2 words
        function speakWord() {
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            const currentCard = currentEpisodeCards[currentCardIndex];
            if (!currentCard.speaker) return; // No word to speak
            
            const utterance = new SpeechSynthesisUtterance(currentCard.speaker);
            
            // Wait for voices to load on mobile browsers
            const voices = speechSynthesis.getVoices();
            if (voices.length === 0) {
                // Retry after voices are loaded
                speechSynthesis.addEventListener('voiceschanged', () => {
                    speakWord();
                }, { once: true });
                return;
            }
            
            // Find Japanese voice
            const selectedVoice = voices.find(voice => 
                voice.lang.startsWith('ja') || voice.name.includes('Japanese') || voice.name.includes('ja-')
            );
            
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            
            utterance.lang = 'ja-JP';
            // Use default settings for individual words
            
            // Visual feedback for speaking
            wordSpeakerBtn.style.background = '#2d7748';
            wordSpeakerBtnBack.style.background = '#2d7748';
            
            utterance.onend = () => {
                wordSpeakerBtn.style.background = '#48bb78';
                wordSpeakerBtnBack.style.background = '#48bb78';
            };
            
            utterance.onerror = () => {
                wordSpeakerBtn.style.background = '#48bb78';
                wordSpeakerBtnBack.style.background = '#48bb78';
                console.warn('Speech synthesis error - Japanese voice may not be available');
            };
            
            speechSynthesis.speak(utterance);
        }

        // Navigation functions
        function goToPreviousCard() {
            if (currentCardIndex > 0) {
                currentCardIndex--;
                loadCard(currentCardIndex);
                updateNavigationButtons();
                
                // Preload audio after navigation
                preloadAudio();
                
                // Aggressively preload current card data immediately
                preloadCurrentCardDataImmediately();
            } else {
                // At first card of episode, try to go to previous episode
                const sequences = Object.keys(episodeData).sort();
                const currentIndex = sequences.indexOf(currentEpisode);
                if (currentIndex > 0) {
                    const previousSequence = sequences[currentIndex - 1];
                    // Load previous sequence and go to its last card
                    loadEpisode(previousSequence);
                    currentCardIndex = currentEpisodeCards.length - 1;
                    
                    if (currentEpisodeCards.length > 0) {
                        loadCard(currentCardIndex);
                        updateNavigationButtons();
                    }
                }
            }
        }

        function goToNextCard() {
            if (currentCardIndex < currentEpisodeCards.length - 1) {
                currentCardIndex++;
                loadCard(currentCardIndex);
                updateNavigationButtons();
                
                // Preload audio after navigation
                preloadAudio();
                
                // Aggressively preload current card data immediately
                preloadCurrentCardDataImmediately();
            } else {
                // At last card of episode, try to go to next episode
                const sequences = Object.keys(episodeData).sort();
                const currentIndex = sequences.indexOf(currentEpisode);
                if (currentIndex < sequences.length - 1) {
                    const nextSequence = sequences[currentIndex + 1];
                    // Load next sequence and go to its first card
                    loadEpisode(nextSequence);
                    currentCardIndex = 0;
                    
                    if (currentEpisodeCards.length > 0) {
                        loadCard(currentCardIndex);
                        updateNavigationButtons();
                    }
                }
            }
        }

        function updateNavigationButtons() {
            prevBtn.disabled = currentCardIndex === 0;
            nextBtn.disabled = currentCardIndex === currentEpisodeCards.length - 1;
        }

        function previousVolume() {
            // Volume navigation placeholder
            console.log('Previous volume clicked');
        }

        function nextVolume() {
            // Volume navigation placeholder
            console.log('Next volume clicked');
        }

        // Event listeners
        // Remove global click event - now handled by clickable areas only
        speakerBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card flip when clicking speaker
            console.log('Speaker button clicked');
            console.log('typeof speakJapanese:', typeof speakJapanese);
            console.log('About to call speakJapanese()');
            try {
                speakJapanese();
                console.log('speakJapanese() call completed');
            } catch (error) {
                console.error('Error calling speakJapanese:', error);
            }
        });
        speakerBtnBack.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card flip when clicking speaker
            speakJapanese();
        });
        // Word speaker buttons are hidden and not used
        prevBtn.addEventListener('click', goToPreviousCard);
        nextBtn.addEventListener('click', goToNextCard);
        
        // Old episode navigation buttons removed from HTML
        
        // New sequence navigation button event listeners
        if (prevSequenceBtn) {
            prevSequenceBtn.addEventListener('click', () => {
                const sequences = Object.keys(episodeData).sort();
                const currentIndex = sequences.indexOf(currentEpisode);
                if (currentIndex > 0) {
                    loadEpisode(sequences[currentIndex - 1]);
                }
            });
        }
        
        if (nextSequenceBtn) {
            nextSequenceBtn.addEventListener('click', () => {
                const sequences = Object.keys(episodeData).sort();
                const currentIndex = sequences.indexOf(currentEpisode);
                if (currentIndex < sequences.length - 1) {
                    loadEpisode(sequences[currentIndex + 1]);
                }
            });
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                    goToPreviousCard();
                    break;
                case 'ArrowRight':
                    goToNextCard();
                    break;
                case ' ':
                case 'Enter':
                    e.preventDefault();
                    flipCard();
                    break;
                case 's':
                case 'S':
                    speakJapanese();
                    break;
            }
        });

        // Load voices when they become available
        speechSynthesis.addEventListener('voiceschanged', () => {
            // Voices are now loaded
        });

        // Initialize the app when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadFlashcardsFromNotion);
        } else {
            loadFlashcardsFromNotion();
        }

        // Handle touch gestures for mobile
        let touchStartX = 0;
        let touchEndX = 0;

        flashcard.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });

        flashcard.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });

        function handleSwipe() {
            const swipeThreshold = 50;
            const swipeDistance = touchEndX - touchStartX;
            
            if (Math.abs(swipeDistance) > swipeThreshold) {
                if (swipeDistance > 0) {
                    // Swipe right - go to previous card
                    goToPreviousCard();
                } else {
                    // Swipe left - go to next card
                    goToNextCard();
                }
            }
        }

        // Expression card modal functions
        function openExpressionModal(expressionCardId) {
            const modal = document.getElementById('expression-modal');
            const modalBody = document.getElementById('expression-modal-body');
            
            // Show modal
            modal.style.display = 'flex';
            
            // Check if expression card data is preloaded
            const currentCardKey = `${currentEpisode}_${currentCardIndex}`;
            const preloadedData = preloadedExpressionCards[currentCardKey];
            
            if (preloadedData && Array.isArray(preloadedData)) {
                console.log('Using preloaded expression card data');
                const expressionCard = preloadedData.find(card => card.id === expressionCardId);
                if (expressionCard) {
                    renderExpressionCard(expressionCard);
                    return;
                }
            }
            
            // Show loading if not preloaded
            modalBody.innerHTML = '<div class="expression-loading">Loading...</div>';
            
            // Fetch expression card data immediately
            console.log('Fetching expression card data for ID:', expressionCardId);
            fetch(`/api/expression-card/${expressionCardId}`)
                .then(response => response.json())
                .then(data => {
                    if (data) {
                        console.log('Expression card data loaded:', data.title);
                        renderExpressionCard(data);
                    } else {
                        modalBody.innerHTML = '<div class="expression-loading">Expression card not found.</div>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching expression card:', error);
                    modalBody.innerHTML = '<div class="expression-loading">Error loading expression card.</div>';
                });
        }

        function closeExpressionModal() {
            const modal = document.getElementById('expression-modal');
            modal.style.display = 'none';
        }

        function openWordModal() {
            console.log('=== openWordModal called ===');
            const modal = document.getElementById('word-modal');
            const modalBody = document.getElementById('word-modal-body');
            
            console.log('modal element:', modal);
            console.log('modalBody element:', modalBody);
            
            modal.style.display = 'flex';
            
            // Get current card data
            const currentCard = currentEpisodeCards[currentCardIndex];
            console.log('currentCard:', currentCard);
            
            // Check if N1 word data is preloaded
            const currentCardKey = `${currentEpisode}_${currentCardIndex}`;
            const preloadedData = preloadedN1WordData[currentCardKey];
            
            if (preloadedData && preloadedData !== 'loading') {
                console.log('Using preloaded N1 word data');
                renderWordModal(preloadedData);
                return;
            }
            
            // Show loading if not preloaded
            modalBody.innerHTML = '<div class="expression-loading">Loading...</div>';
            
            if (!currentCard) {
                modalBody.innerHTML = '<div class="expression-loading">No current card available.</div>';
                return;
            }
            
            if (currentCard.n1VocabularyId) {
                console.log('N1 vocabulary ID found:', currentCard.n1VocabularyId);
                
                // Fetch N1 vocabulary data immediately
                fetch(`/api/n1-vocabulary/${currentCard.n1VocabularyId}`)
                    .then(response => response.json())
                    .then(data => {
                        console.log('N1 vocabulary data loaded:', data);
                        if (data) {
                            renderWordModal(data);
                        } else {
                            modalBody.innerHTML = '<div class="expression-loading">N1 vocabulary not found.</div>';
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching N1 vocabulary:', error);
                        modalBody.innerHTML = '<div class="expression-loading">Error loading N1 vocabulary.</div>';
                    });
            } else {
                // Create word modal content with available data
                const wordData = {
                    word: currentCard.speaker || currentCard.japanese || 'Îã®Ïñ¥ ÏóÜÏùå',
                    reading: currentCard.speakerReading || currentCard.speaker || currentCard.japanese || '',
                    meaning: currentCard.speakerMeaning || 'ÏùòÎØ∏ Ï†ïÎ≥¥ ÏóÜÏùå',
                    sentence: currentCard.japanese || '',
                    sentenceKorean: currentCard.korean || ''
                };
                
                console.log('Using fallback wordData:', wordData);
                renderWordModal(wordData);
            }
        }

        function renderWordModal(data) {
            const modalBody = document.getElementById('word-modal-body');
            
            // Get current card for character image
            const currentCard = currentEpisodeCards[currentCardIndex];
            const characterImage = currentCard?.characterImage || '';
            
            let html = `
                <div class="word-main-section" style="text-align: center;">
                    ${characterImage ? `
                        <div style="margin-bottom: 20px;">
                            <img src="${characterImage}" alt="Ï∫êÎ¶≠ÌÑ∞" style="width: 120px; height: 120px; border-radius: 50%; object-fit: cover;" />
                        </div>
                    ` : ''}
                    <h2 class="word-main-title" onclick="speakJapaneseText('${data.word}')" style="font-size: 36px; margin-bottom: 16px;">
                        ${data.word}
                    </h2>
                    <p class="word-main-reading" style="font-size: 20px; margin-bottom: 12px; color: #666;">
                        ${data.reading}
                    </p>
                    <p class="word-main-meaning" style="font-size: 18px; color: #888;">
                        ${data.meaning}
                    </p>
                </div>
            `;
            
            modalBody.innerHTML = html;
        }

        function closeWordModal() {
            const modal = document.getElementById('word-modal');
            modal.style.display = 'none';
        }

        function openWordModalWithN1Data(vocabulary) {
            console.log('=== openWordModalWithN1Data called ===');
            console.log('vocabulary data:', vocabulary);
            
            const modal = document.getElementById('word-modal');
            const modalBody = document.getElementById('word-modal-body');
            
            modal.style.display = 'flex';
            modalBody.innerHTML = '<div class="expression-loading">Loading...</div>';
            
            // Use N1 vocabulary image from img field
            const vocabularyImage = vocabulary.img || '';
            
            // Create word modal content with N1 vocabulary data
            const wordData = {
                word: vocabulary.word || 'Îã®Ïñ¥ ÏóÜÏùå',
                reading: vocabulary.reading || vocabulary.word || '',
                meaning: vocabulary.meaning || 'ÏùòÎØ∏ Ï†ïÎ≥¥ ÏóÜÏùå',
                example: vocabulary.example || '',
                exampleTranslation: vocabulary.exampleTranslation || ''
            };
            
            let html = `
                <div class="word-main-section" style="text-align: center;">
                    ${vocabularyImage ? `
                        <div style="margin-bottom: 12px; position: relative; display: inline-block;">
                            <img src="${vocabularyImage}" alt="Îã®Ïñ¥ Ïù¥ÎØ∏ÏßÄ" style="width: 90%; max-width: 300px; aspect-ratio: 1/1; border-radius: 12px; object-fit: cover;" />
                            <button class="word-modal-speaker-btn" onclick="speakWordInModal('${wordData.word}')" style="position: absolute; bottom: 16px; right: 35px; width: 40px; height: 40px; border-radius: 50%; background: rgba(66, 153, 225, 0.9); border: none; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                                </svg>
                            </button>
                        </div>
                    ` : ''}
                    <h2 class="word-main-title" onclick="speakWordInModal('${wordData.word}')" style="font-size: 36px; margin-bottom: 2px; cursor: pointer;">
                        ${wordData.word}
                    </h2>
                    <p class="word-main-reading" style="font-size: 20px; margin-bottom: 4px; color: #666;">
                        ${wordData.reading}
                    </p>
                    <p class="word-main-meaning" style="font-size: 18px; color: #888; margin-bottom: 12px;">
                        ${wordData.meaning}
                    </p>
                    ${wordData.example ? `
                        <div class="word-examples" onclick="speakJapaneseExample('${wordData.example.replace(/'/g, "\\'")}'); return false;" style="margin-top: 16px; padding: 16px; background: rgba(0,0,0,0.05); border-radius: 8px; text-align: left; cursor: pointer; transition: background-color 0.2s ease;">
                            <p class="word-example-ja" style="font-size: 16px; color: #333; margin-bottom: 8px; line-height: 1.4;">
                                ${wordData.example}
                            </p>
                            <p class="word-example-ko" style="font-size: 14px; color: #666; margin-bottom: 0; line-height: 1.4;">
                                ${wordData.exampleTranslation}
                            </p>
                        </div>
                    ` : ''}
                </div>
            `;
            
            modalBody.innerHTML = html;
            
            // Adjust modal height based on content
            setTimeout(() => {
                adjustModalHeight();
            }, 50);
        }

        function adjustModalHeight() {
            const modal = document.querySelector('.word-modal-content');
            const modalBody = document.getElementById('word-modal-body');
            
            if (modal && modalBody) {
                // Reset height and overflow first
                modal.style.height = 'auto';
                modal.style.overflowY = 'visible';
                modal.style.maxHeight = '85vh';
                
                // Force reflow
                modal.offsetHeight;
                
                // Get actual content height including margins
                const contentHeight = modalBody.scrollHeight;
                const modalPadding = 40; // 20px top + 20px bottom padding
                const totalHeight = contentHeight + modalPadding;
                const maxHeight = window.innerHeight * 0.85;
                
                // Only add scroll if content truly exceeds viewport
                if (totalHeight > maxHeight) {
                    modal.style.maxHeight = maxHeight + 'px';
                    modal.style.overflowY = 'auto';
                } else {
                    modal.style.height = 'fit-content';
                    modal.style.overflowY = 'visible';
                }
            }
        }

        function speakWordInModal(word) {
            console.log('Speaking word in modal:', word);
            
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            const utterance = new SpeechSynthesisUtterance(word);
            
            // Wait for voices to load on mobile browsers
            const voices = speechSynthesis.getVoices();
            if (voices.length === 0) {
                speechSynthesis.addEventListener('voiceschanged', () => {
                    speakWordInModal(word);
                }, { once: true });
                return;
            }
            
            // Use Japanese voice
            const japaneseVoice = voices.find(voice => voice.lang.startsWith('ja'));
            if (japaneseVoice) {
                utterance.voice = japaneseVoice;
            }
            
            utterance.lang = 'ja-JP';
            utterance.rate = 1.2;
            
            speechSynthesis.speak(utterance);
        }

        function speakJapaneseExample(example) {
            console.log('Speaking Japanese example:', example);
            
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            // Small delay to ensure cancellation is complete
            setTimeout(() => {
                const utterance = new SpeechSynthesisUtterance(example);
                
                // Wait for voices to load on mobile browsers
                const voices = speechSynthesis.getVoices();
                if (voices.length === 0) {
                    speechSynthesis.addEventListener('voiceschanged', () => {
                        speakJapaneseExample(example);
                    }, { once: true });
                    return;
                }
                
                // Use Japanese voice
                const japaneseVoice = voices.find(voice => voice.lang.startsWith('ja'));
                if (japaneseVoice) {
                    utterance.voice = japaneseVoice;
                }
                
                utterance.lang = 'ja-JP';
                utterance.rate = 1.0;
                
                speechSynthesis.speak(utterance);
            }, 100);
        }

        function renderExpressionCard(data) {
            const modalBody = document.getElementById('expression-modal-body');
            
            // console.log('=== Expression Card Data ===');
            // console.log('Full data:', data);
            
            // Prepare applications array
            const applications = [
                { japanese: data.application1, korean: data.application1Korean },
                { japanese: data.application2, korean: data.application2Korean },
                { japanese: data.application3, korean: data.application3Korean },
                { japanese: data.application4, korean: data.application4Korean },
                { japanese: data.application5, korean: data.application5Korean }
            ].filter(app => app.japanese && app.japanese.trim() !== '');
            
            // console.log('Filtered applications:', applications);
            // console.log('Applications count:', applications.length);
            
            let html = `
                <div class="expression-main-section">
                    <h2 class="expression-main-title" onclick="speakJapanese('${data.title}')">
                        ${data.title}
                    </h2>
                    <p class="expression-main-meaning">
                        ${data.meaning}
                    </p>
                </div>
            `;
            
            if (applications.length > 0) {
                html += '<div class="expression-applications">';
                applications.forEach((app, index) => {
                    // console.log(`Rendering application ${index + 1}:`, app);
                    html += `
                        <div class="expression-application-item" onclick="speakJapaneseText('${app.japanese}')">
                            <div class="expression-application-japanese">${app.japanese}</div>
                            <div class="expression-application-korean">${app.korean}</div>
                        </div>
                    `;
                });
                html += '</div>';
                // console.log('Final HTML length:', html.length);
                // console.log('Final HTML preview:', html.substring(0, 500));
            }
            
            modalBody.innerHTML = html;
            
            // Check how many items were actually rendered
            // setTimeout(() => {
            //     const renderedItems = document.querySelectorAll('.expression-application-item');
            //     console.log('Actually rendered items count:', renderedItems.length);
            //     console.log('Modal body HTML:', modalBody.innerHTML);
            // }, 100);
        }

        function speakJapaneseText(text) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel(); // Cancel any ongoing speech
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'ja-JP';
                // Use default rate
                window.speechSynthesis.speak(utterance);
            }
        }

        // Initialize modal event listener after DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            const expressionModal = document.getElementById('expression-modal');
            if (expressionModal) {
                expressionModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeExpressionModal();
                    }
                });
            }
            
            const wordModal = document.getElementById('word-modal');
            if (wordModal) {
                wordModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeWordModal();
                    }
                });
            }
        });
    </script>
    
    <!-- Expression Card Modal -->
    <div class="expression-modal" id="expression-modal">
        <div class="expression-modal-content">
            <button class="expression-modal-close" onclick="closeExpressionModal()">&times;</button>
            <div id="expression-modal-body">
                <div class="expression-loading">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Word Modal -->
    <div id="word-modal" class="word-modal">
        <div class="word-modal-content">
            <div id="word-modal-body">
                <div class="expression-loading">Loading...</div>
            </div>
        </div>
    </div>

</body>
</html>
