<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Japanese Learning Flashcards</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 20px 20px 20px;
        }

        .app-container {
            width: 100%;
            max-width: 400px;
            text-align: center;
            padding: 0 1rem;
        }

        .app-title {
            color: white;
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            margin-top: 0.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .episode-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            gap: 1rem;
        }

        .episode-title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
            font-weight: 400;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .volume-text {
            font-size: 1.1rem;
            font-weight: 400;
        }
        
        .sequence-text {
            font-size: 1.0rem;
            font-weight: 300;
            min-width: 50px;
            text-align: center;
        }
        
        .sequence-nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .sequence-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .sequence-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .db-connection-status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: #F1F8E9;
            color: #555;
            padding: 6px 12px;
            border-radius: 15px;
            border: 0.25px solid #E0E0E0;
            font-size: 1.05rem;
            font-weight: 400;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 10;
            backdrop-filter: blur(5px);
            pointer-events: none;
        }

        .db-status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #C8E6C9;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .episode-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
        }

        .episode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .episode-icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .flashcard-container {
            perspective: 1000px;
            margin-bottom: 2rem;
        }

        .flashcard {
            width: 100%;
            aspect-ratio: 3/4;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0.2, 0.2, 1);
            cursor: pointer;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 2rem;
            background: white;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            box-sizing: border-box;
        }

        .card-front {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9ff 100%);
        }

        .card-back {
            background: linear-gradient(135deg, #fff5f5 0%, #ffe6e6 100%);
            transform: rotateY(180deg);
        }

        .japanese-text {
            font-size: 1.4rem;
            font-weight: 500;
            color: #2d3748;
            line-height: 1.6;
            margin-bottom: 1rem;
            text-align: center;
        }

        .korean-text {
            font-size: 1.1rem;
            color: #4a5568;
            line-height: 1.5;
            text-align: center;
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        .speaker-btn {
            background: #4299e1;
            border: none;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            font-size: 1rem;
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            box-shadow: 0 2px 8px rgba(66, 153, 225, 0.3);
            z-index: 10;
        }

        .speaker-btn:hover {
            background: #3182ce;
            transform: scale(1.05);
        }

        .speaker-btn:active {
            transform: scale(0.95);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            color: white;
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .card-counter {
            color: white;
            font-size: 1rem;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .flip-instruction {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9rem;
            margin-top: 1rem;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .speaker-icon {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        .speaker-btn {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            background: #4299e1;
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 10;
        }

        .word-speaker-btn {
            display: none;
        }

        .speaker-btn:hover {
            background: #3182ce;
            transform: scale(1.05);
        }



        .nav-icon {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .card-clickable-area {
            height: 80%;
            cursor: pointer;
        }
        
        .character-avatar {
            width: 128px;
            height: 128px;
            border-radius: 50%;
            background: transparent;
            margin: 1.5rem auto 2rem auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            border: 1px solid rgba(128, 128, 128, 0.3);
            overflow: hidden;
            flex-shrink: 0;
            position: relative;
        }

        .character-avatar img {
            width: 128px;
            height: 128px;
            object-fit: cover;
            border-radius: 50%;
            position: absolute;
            top: -1px;
            left: -1px;
        }

        .speaker-name {
            display: none;
        }

        /* Mobile optimizations */
        @media (max-width: 480px) {
            body {
                padding: 0;
                justify-content: flex-start;
                align-items: stretch;
                min-height: 100vh;
            }
            
            .app-container {
                padding: 0.5rem;
                margin-top: 0;
                height: 100vh;
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
            }
            
            .app-title {
                font-size: 1.5rem;
                margin-top: 0;
                margin-bottom: 0;
                display: none;
            }
            
            .episode-nav {
                margin-bottom: 0.5rem;
                margin-top: 0.5rem;
            }
            
            .episode-title {
                margin-bottom: 0;
            }

            .flashcard {
                aspect-ratio: 3/4;
                width: calc(100% - 2rem);
                margin: 0 auto;
            }

            .card-face {
                padding: 1rem;
            }

            .japanese-text {
                font-size: 1.32rem;
                line-height: 1.4;
                margin-bottom: 0.75rem;
            }

            .korean-text {
                font-size: 0.95rem;
                margin-top: 0.5rem;
            }
            
            .speaker-btn {
                width: 3.5rem;
                height: 3.5rem;
                bottom: 0.75rem;
                right: 0.75rem;
                font-size: 1.2rem;
            }
            
            .word-speaker-btn {
                width: 3.5rem;
                height: 3.5rem;
                bottom: 0.75rem;
                left: 0.75rem;
                font-size: 1.2rem;
            }
            
            .speaker-icon {
                width: 28px;
                height: 28px;
            }
            
            .character-avatar {
                width: 96px;
                height: 96px;
                margin-bottom: 0.75rem;
                font-size: 3.2rem;
            }
            
            .character-avatar img {
                width: 96px;
                height: 96px;
            }
            
            .speaker-name {
                font-size: 1.1rem;
                margin-bottom: 1rem;
            }

            .nav-btn {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            .controls {
                margin-top: 1rem;
            }
            
            .flashcard-container {
                margin-bottom: 1rem;
            }
        }

        /* Touch improvements */
        @media (hover: none) and (pointer: coarse) {
            .flashcard {
                -webkit-tap-highlight-color: transparent;
            }

            .speaker-btn:hover {
                transform: none;
                background: #4299e1;
            }

            .nav-btn:hover {
                transform: none;
                background: rgba(255, 255, 255, 0.2);
                border-color: rgba(255, 255, 255, 0.3);
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="episode-nav">
            <div class="episode-title" id="episode-title">
                <span class="volume-text">26ê¶Œ</span>
                <button class="sequence-nav-btn" id="prev-sequence-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                    </svg>
                </button>
                <span class="sequence-text" id="sequence-text">#001</span>
                <button class="sequence-nav-btn" id="next-sequence-btn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <div class="flashcard-container">
            <div class="flashcard" id="flashcard">
                <div class="card-face card-front">
                    <div class="card-clickable-area" onclick="flipCard()">
                        <div class="character-avatar" id="character-avatar"></div>
                        <div class="speaker-name" id="speaker-name"></div>
                        <div class="japanese-text" id="japanese-text"></div>
                    </div>
                    <button class="speaker-btn" id="speaker-btn" title="Listen to pronunciation">
                        <svg class="speaker-icon" viewBox="0 0 24 24">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                        </svg>
                    </button>
                    <button class="word-speaker-btn" id="word-speaker-btn" title="Listen to word pronunciation">
                        <svg class="speaker-icon" viewBox="0 0 24 24">
                            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                        </svg>
                    </button>
                    <div class="db-connection-status" id="db-status-front">
                        <div class="db-status-dot"></div>
                        <span id="db-status-text-front"></span>
                    </div>
                </div>
                <div class="card-face card-back">
                    <div class="card-clickable-area" onclick="flipCard()">
                        <div class="character-avatar" id="character-avatar-back"></div>
                        <div class="japanese-text" id="japanese-text-back"></div>
                        <div class="korean-text" id="korean-text"></div>
                    </div>
                    <button class="speaker-btn" id="speaker-btn-back" title="Listen to pronunciation">
                        <svg class="speaker-icon" viewBox="0 0 24 24">
                            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                        </svg>
                    </button>
                    <button class="word-speaker-btn" id="word-speaker-btn-back" title="Listen to word pronunciation">
                        <svg class="speaker-icon" viewBox="0 0 24 24">
                            <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                        </svg>
                    </button>
                    <div class="db-connection-status" id="db-status-back">
                        <div class="db-status-dot"></div>
                        <span id="db-status-text-back"></span>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="nav-btn" id="prev-btn">
                <svg class="nav-icon" viewBox="0 0 24 24">
                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                </svg>
            </button>
            <div class="card-counter">
                <span id="current-card">1</span> / <span id="total-cards">3</span>
            </div>
            <button class="nav-btn" id="next-btn">
                <svg class="nav-icon" viewBox="0 0 24 24">
                    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                </svg>
            </button>
        </div>
    </div>

    <script>
        // Flashcard data - will be loaded from Notion
        let flashcards = [];

        let currentCardIndex = 0;
        let isFlipped = false;

        // DOM elements
        const flashcard = document.getElementById('flashcard');
        const japaneseText = document.getElementById('japanese-text');
        const japaneseTextBack = document.getElementById('japanese-text-back');
        const koreanText = document.getElementById('korean-text');
        const characterAvatar = document.getElementById('character-avatar');
        const characterAvatarBack = document.getElementById('character-avatar-back');
        const speakerName = document.getElementById('speaker-name');
        const speakerBtn = document.getElementById('speaker-btn');
        const speakerBtnBack = document.getElementById('speaker-btn-back');
        const wordSpeakerBtn = document.getElementById('word-speaker-btn');
        const wordSpeakerBtnBack = document.getElementById('word-speaker-btn-back');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const currentCardSpan = document.getElementById('current-card');
        const totalCardsSpan = document.getElementById('total-cards');
        const episodeTitle = document.getElementById('episode-title');
        // Remove unused episode buttons that were deleted from HTML
        const prevSequenceBtn = document.getElementById('prev-sequence-btn');
        const nextSequenceBtn = document.getElementById('next-sequence-btn');
        const dbStatusFront = document.getElementById('db-status-front');
        const dbStatusBack = document.getElementById('db-status-back');
        const dbStatusTextFront = document.getElementById('db-status-text-front');
        const dbStatusTextBack = document.getElementById('db-status-text-back');

        // Load flashcards from Notion
        async function loadFlashcardsFromNotion() {
            try {
                const response = await fetch('/api/flashcards');
                if (!response.ok) {
                    throw new Error('Failed to fetch flashcards');
                }
                const data = await response.json();
                flashcards = data;
                
                if (flashcards.length === 0) {
                    showError('ë…¸ì…˜ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ í”Œëž˜ì‹œì¹´ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                init();
            } catch (error) {
                console.error('Error loading flashcards:', error);
                // Only show error if there's actually a fetch problem
                if (error.message.includes('fetch') || error.message.includes('Failed to fetch')) {
                    showError('ë…¸ì…˜ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }
            }
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #ff6b6b;
                color: white;
                padding: 20px;
                border-radius: 8px;
                text-align: center;
                z-index: 1000;
            `;
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
        }

        // Episode management
        let currentEpisode = 1;
        let episodeData = {};
        let currentEpisodeCards = [];

        // Parse sequence data from flashcards
        function parseEpisodes() {
            episodeData = {};
            flashcards.forEach((card, index) => {
                // Group by sequence instead of episode
                const sequence = card.sequence || '#001';
                
                if (!episodeData[sequence]) {
                    episodeData[sequence] = [];
                }
                
                // Sort by romanji (sequence number)
                const sortOrder = parseInt(card.romanji) || (index + 1);
                episodeData[sequence].push({...card, sentenceNum: sortOrder});
            });
            
            // Sort sentences within each episode
            Object.keys(episodeData).forEach(ep => {
                episodeData[ep].sort((a, b) => a.sentenceNum - b.sentenceNum);
            });
            
            // Set current sequence to first available
            const availableSequences = Object.keys(episodeData).sort();
            if (availableSequences.length > 0) {
                currentEpisode = availableSequences[0]; // Use currentEpisode variable for sequence
                loadEpisode(currentEpisode);
            }
        }

        // Load cards for specific sequence
        function loadEpisode(sequenceName) {
            currentEpisode = sequenceName;
            currentEpisodeCards = episodeData[sequenceName] || [];
            currentCardIndex = 0;
            
            // Update title to show volume and sequence
            const firstCard = currentEpisodeCards[0];
            const volume = firstCard?.volume || '26ê¶Œ';
            
            // Update volume and sequence text
            const volumeText = document.querySelector('.volume-text');
            const sequenceText = document.querySelector('.sequence-text');
            if (volumeText) volumeText.textContent = volume;
            if (sequenceText) sequenceText.textContent = sequenceName;
            
            if (currentEpisodeCards.length > 0) {
                // Sort cards by sequence number (romanji) in ascending order
                currentEpisodeCards.sort((a, b) => {
                    const aNum = parseInt(a.romanji) || 0;
                    const bNum = parseInt(b.romanji) || 0;
                    return aNum - bNum; // Ascending order
                });
                
                loadCard(currentCardIndex);
                totalCardsSpan.textContent = currentEpisodeCards.length;
                updateNavigationButtons();
                updateEpisodeButtons();
            }
        }

        // Update sequence navigation buttons
        function updateEpisodeButtons() {
            const sequences = Object.keys(episodeData).sort();
            const currentIndex = sequences.indexOf(currentEpisode);
            
            // Update sequence navigation buttons
            if (prevSequenceBtn) {
                prevSequenceBtn.disabled = currentIndex <= 0;
            }
            if (nextSequenceBtn) {
                nextSequenceBtn.disabled = currentIndex >= sequences.length - 1;
            }
            
            // Episode buttons have been removed from HTML
        }

        // Get diverse emoji based on sentence index and content
        function getEmojiForSentence(japanese, cardIndex = 0) {
            // Wide variety of emojis to ensure diversity
            const emojiPool = [
                'ðŸ˜Š', 'ðŸ˜„', 'ðŸ˜ƒ', 'ðŸ˜€', 'ðŸ˜', 'ðŸ™‚', 'ðŸ˜‡', 'ðŸ˜†', 'ðŸ¤£', 'ðŸ˜‚',
                'ðŸ¥°', 'ðŸ˜', 'ðŸ¤©', 'ðŸ˜‹', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜Ž', 'ðŸ¤“', 'ðŸ¥³', 'ðŸ˜Œ',
                'ðŸ˜‰', 'ðŸ˜', 'ðŸ™ƒ', 'ðŸ˜—', 'ðŸ˜™', 'ðŸ˜š', 'ðŸ¤—', 'ðŸ¤­', 'ðŸ¤«', 'ðŸ¤¨',
                'ðŸ˜', 'ðŸ˜‘', 'ðŸ™„', 'ðŸ˜¶', 'ðŸ˜¯', 'ðŸ˜®', 'ðŸ˜²', 'ðŸ˜µ', 'ðŸ¤¯', 'ðŸ¥´',
                'ðŸ¤”', 'ðŸ¤', 'ðŸ¤¥', 'ðŸ˜´', 'ðŸ˜ª', 'ðŸ¥±', 'ðŸ˜”', 'ðŸ˜Ÿ', 'ðŸ˜•', 'ðŸ™',
                'â˜¹ï¸', 'ðŸ˜£', 'ðŸ˜–', 'ðŸ˜«', 'ðŸ˜©', 'ðŸ¥º', 'ðŸ˜¢', 'ðŸ˜­', 'ðŸ˜¤', 'ðŸ˜ ',
                'ðŸ˜¡', 'ðŸ¤¬', 'ðŸ¤¯', 'ðŸ˜³', 'ðŸ¥µ', 'ðŸ¥¶', 'ðŸ˜±', 'ðŸ˜¨', 'ðŸ˜°', 'ðŸ˜¥',
                'ðŸ˜“', 'ðŸ¤—', 'ðŸ¤¢', 'ðŸ¤®', 'ðŸ¤§', 'ðŸ˜·', 'ðŸ¤’', 'ðŸ¤•', 'ðŸ¤ ', 'ðŸ˜ˆ',
                'ðŸ‘¿', 'ðŸ‘¹', 'ðŸ‘º', 'ðŸ¤¡', 'ðŸ’©', 'ðŸ‘»', 'ðŸ’€', 'â˜ ï¸', 'ðŸ‘½', 'ðŸ‘¾',
                'ðŸ¤–', 'ðŸŽ­', 'ðŸ’', 'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’ž', 'ðŸ’•', 'ðŸ’Ÿ', 'â£ï¸',
                'ðŸ’”', 'â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ¤', 'ðŸ¤Ž',
                'ðŸ’‹', 'ðŸ’¯', 'ðŸ’¢', 'ðŸ’¥', 'ðŸ’«', 'ðŸ’¦', 'ðŸ’¨', 'ðŸ•³ï¸', 'ðŸ’£', 'ðŸ’¬',
                'ðŸ‘ï¸', 'ðŸ—¨ï¸', 'ðŸ—¯ï¸', 'ðŸ’­', 'ðŸ’¤', 'ðŸ‘‹', 'ðŸ¤š', 'ðŸ–ï¸', 'âœ‹', 'ðŸ––',
                'ðŸ‘Œ', 'ðŸ¤Œ', 'ðŸ¤', 'âœŒï¸', 'ðŸ¤ž', 'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ¤™', 'ðŸ‘ˆ', 'ðŸ‘‰',
                'ðŸ‘†', 'ðŸ–•', 'ðŸ‘‡', 'â˜ï¸', 'ðŸ‘', 'ðŸ‘Ž', 'ðŸ‘Š', 'âœŠ', 'ðŸ¤›', 'ðŸ¤œ'
            ];
            
            // Use card index to ensure variety across consecutive cards
            let baseIndex = cardIndex % emojiPool.length;
            
            // Add some randomness based on text content
            const textHash = japanese.split('').reduce((hash, char) => {
                return ((hash << 5) - hash + char.charCodeAt(0)) & 0xffffffff;
            }, 0);
            
            const finalIndex = (baseIndex + Math.abs(textHash) % 20) % emojiPool.length;
            
            // Still check for specific emotional content to override with appropriate emojis
            const text = japanese.toLowerCase();
            
            if (text.includes('ï¼Ÿ') || text.includes('?')) {
                const questionEmojis = ['â“', 'â”', 'ðŸ¤”', 'ðŸ§', 'ðŸ’­', 'ðŸ¤·', 'ðŸ™‹'];
                return questionEmojis[Math.abs(textHash) % questionEmojis.length];
            }
            
            if (text.includes('ã‚ã‚ŠãŒã¨ã†') || text.includes('æ„Ÿè¬')) {
                const thankfulEmojis = ['ðŸ˜Š', 'ðŸ™', 'ðŸ˜‡', 'ðŸ¥°', 'ðŸ˜', 'ðŸ’–', 'âœ¨'];
                return thankfulEmojis[Math.abs(textHash) % thankfulEmojis.length];
            }
            
            if (text.includes('ã™ã¿ã¾ã›ã‚“') || text.includes('ã”ã‚ã‚“')) {
                const sorryEmojis = ['ðŸ˜…', 'ðŸ˜“', 'ðŸ™‡', 'ðŸ˜”', 'ðŸ˜ž', 'ðŸ¥º', 'ðŸ˜°'];
                return sorryEmojis[Math.abs(textHash) % sorryEmojis.length];
            }
            
            if (text.includes('ã†ã‚Œã—ã„') || text.includes('æ¥½ã—ã„') || text.includes('ã‚ˆã‹ã£ãŸ')) {
                const happyEmojis = ['ðŸ˜„', 'ðŸ˜', 'ðŸ¥³', 'ðŸ˜†', 'ðŸ¤©', 'âœ¨', 'ðŸŽ‰', 'ðŸ’ƒ'];
                return happyEmojis[Math.abs(textHash) % happyEmojis.length];
            }
            
            if (text.includes('æ‚²ã—ã„') || text.includes('ã¤ã‚‰ã„')) {
                const sadEmojis = ['ðŸ˜¢', 'ðŸ˜­', 'ðŸ˜”', 'ðŸ˜ž', 'ðŸ¥º', 'ðŸ’”', 'ðŸ˜¿'];
                return sadEmojis[Math.abs(textHash) % sadEmojis.length];
            }
            
            if (text.includes('é£Ÿã¹') || text.includes('é£²ã¿') || text.includes('ç¾Žå‘³')) {
                const foodEmojis = ['ðŸ˜‹', 'ðŸ¤¤', 'ðŸ½ï¸', 'ðŸ¥¢', 'ðŸœ', 'ðŸ±', 'ðŸ”', 'ðŸ¥—'];
                return foodEmojis[Math.abs(textHash) % foodEmojis.length];
            }
            
            if (text.includes('å‹‰å¼·') || text.includes('å­¦') || text.includes('èª­')) {
                const studyEmojis = ['ðŸ“š', 'âœï¸', 'ðŸ“', 'ðŸŽ“', 'ðŸ¤“', 'ðŸ’¡', 'ðŸ“–', 'âœï¸'];
                return studyEmojis[Math.abs(textHash) % studyEmojis.length];
            }
            
            if (text.includes('ä»•äº‹') || text.includes('åƒ')) {
                const workEmojis = ['ðŸ’¼', 'ðŸ’»', 'ðŸ“Š', 'âš¡', 'ðŸŽ¯', 'ðŸ“ˆ', 'ðŸ¢', 'â°'];
                return workEmojis[Math.abs(textHash) % workEmojis.length];
            }
            
            // Return emoji from the diverse pool
            return emojiPool[finalIndex];
        }

        // Initialize the app
        function init() {
            parseEpisodes();
        }

        // Load a specific card
        function loadCard(index) {
            if (index < 0 || index >= currentEpisodeCards.length) return;
            
            const card = currentEpisodeCards[index];
            japaneseText.textContent = card.japanese;
            japaneseTextBack.textContent = card.japanese;
            koreanText.textContent = card.korean;
            speakerName.textContent = card.speaker || "";
            currentCardSpan.textContent = index + 1;
            
            // Set character avatar for both front and back - use image if available, otherwise emoji based on sentence mood
            if (card.characterImage) {
                characterAvatar.innerHTML = `<img src="${card.characterImage}" alt="${card.speaker}" />`;
                characterAvatarBack.innerHTML = `<img src="${card.characterImage}" alt="${card.speaker}" />`;
            } else {
                const emoji = getEmojiForSentence(card.japanese, index);
                characterAvatar.textContent = emoji;
                characterAvatarBack.textContent = emoji;
            }
            
            // Update database connection status
            updateDBStatus(card);
            
            // Reset flip state
            if (isFlipped) {
                flipCard();
            }
        }
        
        // Update database connection status based on card data
        async function updateDBStatus(card) {
            // Check if card has expression card relation
            if (card.expressionCardId) {
                try {
                    const response = await fetch(`/api/expression-card/${card.expressionCardId}`);
                    const expressionCard = await response.json();
                    
                    if (expressionCard && expressionCard.title) {
                        // Display expression card title only
                        const statusText = expressionCard.title;
                        
                        if (dbStatusTextFront) dbStatusTextFront.textContent = statusText;
                        if (dbStatusTextBack) dbStatusTextBack.textContent = statusText;
                        
                        if (dbStatusFront) dbStatusFront.style.display = 'flex';
                        if (dbStatusBack) dbStatusBack.style.display = 'flex';
                    } else {
                        // Hide if no valid expression card info
                        if (dbStatusFront) dbStatusFront.style.display = 'none';
                        if (dbStatusBack) dbStatusBack.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Error fetching expression card info:', error);
                    // Hide status if error
                    if (dbStatusFront) dbStatusFront.style.display = 'none';
                    if (dbStatusBack) dbStatusBack.style.display = 'none';
                }
            } else {
                // Hide status if no expression card relation
                if (dbStatusFront) dbStatusFront.style.display = 'none';
                if (dbStatusBack) dbStatusBack.style.display = 'none';
            }
        }
        


        // Flip the card
        function flipCard() {
            flashcard.classList.toggle('flipped');
            isFlipped = !isFlipped;
        }

        // Text-to-speech functionality
        function speakJapanese() {
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            const currentCard = currentEpisodeCards[currentCardIndex];
            const utterance = new SpeechSynthesisUtterance(currentCard.japanese);
            
            // Wait for voices to load on mobile browsers
            const voices = speechSynthesis.getVoices();
            if (voices.length === 0) {
                // Retry after voices are loaded
                speechSynthesis.addEventListener('voiceschanged', () => {
                    speakJapanese();
                }, { once: true });
                return;
            }
            
            // Try to use Japanese voice based on character gender
            let selectedVoice = null;
            
            if (currentCard.gender === 'ì—¬') {
                // Find female Japanese voice - try multiple patterns for mobile compatibility
                selectedVoice = voices.find(voice => 
                    (voice.lang.startsWith('ja') || voice.name.includes('Japanese') || voice.name.includes('ja-')) &&
                    (voice.name.includes('Female') || voice.name.includes('female') || 
                     voice.name.includes('Woman') || voice.name.includes('woman') ||
                     voice.name.includes('Kyoko') || voice.name.includes('Otoya') ||
                     voice.name.includes('å¥³') || voice.name.toLowerCase().includes('f'))
                ) || voices.find(voice => 
                    (voice.lang === 'ja-JP' || voice.lang === 'ja') && 
                    !voice.name.toLowerCase().includes('male') && !voice.name.toLowerCase().includes('man')
                );
            } else if (currentCard.gender === 'ë‚¨') {
                // Find male Japanese voice - try multiple patterns for mobile compatibility
                selectedVoice = voices.find(voice => 
                    (voice.lang.startsWith('ja') || voice.name.includes('Japanese') || voice.name.includes('ja-')) &&
                    (voice.name.includes('Male') || voice.name.includes('male') || 
                     voice.name.includes('Man') || voice.name.includes('man') ||
                     voice.name.includes('Kenji') || voice.name.includes('Hattori') ||
                     voice.name.includes('ç”·') || voice.name.toLowerCase().includes('m'))
                ) || voices.find(voice => 
                    (voice.lang === 'ja-JP' || voice.lang === 'ja') && 
                    (voice.name.toLowerCase().includes('male') || voice.name.toLowerCase().includes('man'))
                );
            }
            
            // Fallback to any Japanese voice
            if (!selectedVoice) {
                selectedVoice = voices.find(voice => 
                    voice.lang.startsWith('ja') || voice.name.includes('Japanese')
                );
            }
            
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            
            utterance.lang = 'ja-JP';
            utterance.rate = 0.8;
            
            // Adjust pitch based on gender - more pronounced difference for mobile
            if (currentCard.gender === 'ì—¬') {
                utterance.pitch = 1.3; // Higher pitch for female
            } else if (currentCard.gender === 'ë‚¨') {
                utterance.pitch = 0.7; // Lower pitch for male
            } else {
                utterance.pitch = 1.0; // Default pitch
            }
            
            // Visual feedback for speaking
            speakerBtn.style.background = '#2b6cb0';
            speakerBtnBack.style.background = '#2b6cb0';
            
            utterance.onend = () => {
                speakerBtn.style.background = '#4299e1';
                speakerBtnBack.style.background = '#4299e1';
            };
            
            utterance.onerror = () => {
                speakerBtn.style.background = '#4299e1';
                speakerBtnBack.style.background = '#4299e1';
                console.warn('Speech synthesis error - Japanese voice may not be available');
                
                // Log available voices for debugging on mobile
                console.log('Available voices:', voices.map(v => `${v.name} (${v.lang})`));
            };
            
            speechSynthesis.speak(utterance);
        }

        // Text-to-speech for N2 words
        function speakWord() {
            // Cancel any ongoing speech
            speechSynthesis.cancel();
            
            const currentCard = currentEpisodeCards[currentCardIndex];
            if (!currentCard.speaker) return; // No word to speak
            
            const utterance = new SpeechSynthesisUtterance(currentCard.speaker);
            
            // Wait for voices to load on mobile browsers
            const voices = speechSynthesis.getVoices();
            if (voices.length === 0) {
                // Retry after voices are loaded
                speechSynthesis.addEventListener('voiceschanged', () => {
                    speakWord();
                }, { once: true });
                return;
            }
            
            // Find Japanese voice
            const selectedVoice = voices.find(voice => 
                voice.lang.startsWith('ja') || voice.name.includes('Japanese') || voice.name.includes('ja-')
            );
            
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }
            
            utterance.lang = 'ja-JP';
            utterance.rate = 0.7; // Slower for individual words
            utterance.pitch = 1.0;
            
            // Visual feedback for speaking
            wordSpeakerBtn.style.background = '#2d7748';
            wordSpeakerBtnBack.style.background = '#2d7748';
            
            utterance.onend = () => {
                wordSpeakerBtn.style.background = '#48bb78';
                wordSpeakerBtnBack.style.background = '#48bb78';
            };
            
            utterance.onerror = () => {
                wordSpeakerBtn.style.background = '#48bb78';
                wordSpeakerBtnBack.style.background = '#48bb78';
                console.warn('Speech synthesis error - Japanese voice may not be available');
            };
            
            speechSynthesis.speak(utterance);
        }

        // Navigation functions
        function goToPreviousCard() {
            if (currentCardIndex > 0) {
                currentCardIndex--;
                loadCard(currentCardIndex);
                updateNavigationButtons();
            } else {
                // At first card of episode, try to go to previous episode
                const sequences = Object.keys(episodeData).sort();
                const currentIndex = sequences.indexOf(currentEpisode);
                if (currentIndex > 0) {
                    const previousSequence = sequences[currentIndex - 1];
                    // Load previous sequence and go to its last card
                    loadEpisode(previousSequence);
                    currentCardIndex = currentEpisodeCards.length - 1;
                    
                    if (currentEpisodeCards.length > 0) {
                        loadCard(currentCardIndex);
                        updateNavigationButtons();
                    }
                }
            }
        }

        function goToNextCard() {
            if (currentCardIndex < currentEpisodeCards.length - 1) {
                currentCardIndex++;
                loadCard(currentCardIndex);
                updateNavigationButtons();
            } else {
                // At last card of episode, try to go to next episode
                const sequences = Object.keys(episodeData).sort();
                const currentIndex = sequences.indexOf(currentEpisode);
                if (currentIndex < sequences.length - 1) {
                    const nextSequence = sequences[currentIndex + 1];
                    // Load next sequence and go to its first card
                    loadEpisode(nextSequence);
                    currentCardIndex = 0;
                    
                    if (currentEpisodeCards.length > 0) {
                        loadCard(currentCardIndex);
                        updateNavigationButtons();
                    }
                }
            }
        }

        function updateNavigationButtons() {
            prevBtn.disabled = currentCardIndex === 0;
            nextBtn.disabled = currentCardIndex === currentEpisodeCards.length - 1;
        }

        // Event listeners
        // Remove global click event - now handled by clickable areas only
        speakerBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card flip when clicking speaker
            speakJapanese();
        });
        speakerBtnBack.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card flip when clicking speaker
            speakJapanese();
        });
        wordSpeakerBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card flip when clicking speaker
            speakWord();
        });
        wordSpeakerBtnBack.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card flip when clicking speaker
            speakWord();
        });
        prevBtn.addEventListener('click', goToPreviousCard);
        nextBtn.addEventListener('click', goToNextCard);
        
        // Old episode navigation buttons removed from HTML
        
        // New sequence navigation button event listeners
        if (prevSequenceBtn) {
            prevSequenceBtn.addEventListener('click', () => {
                const sequences = Object.keys(episodeData).sort();
                const currentIndex = sequences.indexOf(currentEpisode);
                if (currentIndex > 0) {
                    loadEpisode(sequences[currentIndex - 1]);
                }
            });
        }
        
        if (nextSequenceBtn) {
            nextSequenceBtn.addEventListener('click', () => {
                const sequences = Object.keys(episodeData).sort();
                const currentIndex = sequences.indexOf(currentEpisode);
                if (currentIndex < sequences.length - 1) {
                    loadEpisode(sequences[currentIndex + 1]);
                }
            });
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                    goToPreviousCard();
                    break;
                case 'ArrowRight':
                    goToNextCard();
                    break;
                case ' ':
                case 'Enter':
                    e.preventDefault();
                    flipCard();
                    break;
                case 's':
                case 'S':
                    speakJapanese();
                    break;
            }
        });

        // Load voices when they become available
        speechSynthesis.addEventListener('voiceschanged', () => {
            // Voices are now loaded
        });

        // Initialize the app when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadFlashcardsFromNotion);
        } else {
            loadFlashcardsFromNotion();
        }

        // Handle touch gestures for mobile
        let touchStartX = 0;
        let touchEndX = 0;

        flashcard.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });

        flashcard.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });

        function handleSwipe() {
            const swipeThreshold = 50;
            const swipeDistance = touchEndX - touchStartX;
            
            if (Math.abs(swipeDistance) > swipeThreshold) {
                if (swipeDistance > 0) {
                    // Swipe right - go to previous card
                    goToPreviousCard();
                } else {
                    // Swipe left - go to next card
                    goToNextCard();
                }
            }
        }
    </script>
    

</body>
</html>
